<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喃声细语</title>
  <subtitle>开始</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.wuwii.com/"/>
  <updated>2017-11-24T08:57:55.559Z</updated>
  <id>http://blog.wuwii.com/</id>
  
  <author>
    <name>Slience</name>
    <email>k@wuwii.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用一生的时光去守护你</title>
    <link href="http://blog.wuwii.com/a-living-time.html"/>
    <id>http://blog.wuwii.com/a-living-time.html</id>
    <published>2017-11-23T14:08:03.000Z</published>
    <updated>2017-11-24T08:57:55.559Z</updated>
    
    <content type="html"><![CDATA[<p>今天听电台上逛到了这篇文章，首先想到的应该是爸妈那一代人，是我们比较熟悉的，那缝纫机，我家里现在还能用了；我小时候学习骑车的时候，用的就是当初爸妈结婚的时候自行车；还有当时的小彩电，被我拿来打游戏机了……现在想起来，惭愧的很，没能好好珍惜，那是属于父母的美好记忆的一部分。当然都过去好久了，我的记忆力还是不错的，虽然大多数东西已经不存在了，但是能一直存在我的记忆里，我想爸妈也是一直记得的，而且现在家庭幸福，就足够了。</p>
<p>文章来自网上，百度标题就有，读起来可以细细品尝，喝杯水，别是一番风味。</p>
<p>记录到博客。</p>
<hr>
<p><img src="http://p3.pstatp.com/large/6d100072fd427166ee8" alt="image"></p>
<p><strong>五六十年代的爱情，没有绚烂的色彩，却有着耐人寻味的真情。</strong></p>
<p><img src="http://p9.pstatp.com/large/71e00034b657f43e581" alt="image"></p>
<p><strong>那个时候，总有做不完的农活，苦中作乐就是甜蜜的爱情。</strong></p>
<p><img src="http://p3.pstatp.com/large/6d100072fd55d030dc9" alt="image"></p>
<p><strong>在当时，为心爱的女人戴上一朵红花，是爱情的见证，更是一种矢志不渝的承诺。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/5ce0edf0e5cb48349c356321d86143f4_th.jpg" alt="image"></p>
<p><strong>结婚前不需贵重的礼品，一支钢笔就是一个深刻的纪念。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/00208259a24e47e3ac983be8d1b478b3_th.jpg" alt="image"></p>
<p><strong>那时候结婚，还需要组织上开个介绍信。接过结婚证书的时候，开心到说不出话来。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/255bedb9b6fa44f1a456851c89e3cf34_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/46d488275a0e4b5ea018a421e609788c_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/0b1bd30a0f624ffab5df7bd8c338ac6c_th.jpg" alt="image"></p>
<p><strong>那时候的爱情，总是有众人的见证。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/9c81860520044b9aaf0cae637d370a13_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/16c9b7f033c3440191d7405f39384f44_th.jpg" alt="image"></p>
<p><strong>到了七十年代，爱情故事也随着时代而发生改变。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/1077aaf711ac41ecb555bc662085cd42_th.jpg" alt="image"></p>
<p><strong>在那个特殊的年代，爱情是被禁止的羞涩。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/c1ebcfd1f6dd4e9ba01d934b74b467a3_th.jpg" alt="image"></p>
<p><strong>“恋爱”“结婚”，是资产阶级思想的自由化产物，“男女关系”是绝对要划清界限的个人守则。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/527e2229d3f54a9d9b9402ede6a842ec_th.jpg" alt="image"></p>
<p>**那个时代的人们单纯，生怕别人误会自己有不正当男女关系，生怕别人误会老家来的表哥是自己的汉子</p>
<p><img src="http://img.mp.itc.cn/upload/20160528/a0ea7bc642844de3b6b91408136a2bc0_th.jpg" alt="image"></p>
<p><strong>那时候，连牵个小手都得偷偷摸摸的，一根小小的竹竿连接着他们青涩的爱情。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/b2eb2ef274454388957f69b23f3106db_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/061b45c9946b43708f3f8ceaa25ecc5d_th.jpg" alt="image"></p>
<p><strong>那时候的爱情，也是政治。身穿军装、手捧毛主席语录照相，是那个年代最独特的记忆。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/88071ca9faa34ebdb452aa21b868974e_th.jpg" alt="image"></p>
<p><strong>80年代，有了一种独特的恋爱方式，叫做联谊。说说笑笑，感情自然而然地发生。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/8e1e1034d8494186b87f7c9197deb69f_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/c4cdf0604fc64f21a78403396b53bc4a_th.jpg" alt="image"></p>
<p><strong>在没有电话、电脑的年代，写信寄照片是唯一联系情感的方式。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/54c2769ec19947e3b9a4ef22abd85d82_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/99aefc436e9647ba9a98634a0ba44d53_th.jpg" alt="image"></p>
<p><strong>那时候的约会很简单，坐趟公交车到郊外走走，到湖边划划小船。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/b5138d92ebe849a1b74009a3e711f0c8_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/393d7c957d014d5e90474250d7ebe211_th.jpg" alt="image"></p>
<p><strong>只要两个人在一起，在公园的长椅上坐上一个下午也不会觉得无聊。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/332b5900b72d4fc1a1bf3635a9ee2631_th.jpg" alt="image"></p>
<p><strong>骑着自行车，载着心爱的那个她，真希望时光就停留在这一刻。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/101a7ea965a24e52b398902c74115828_th.jpg" alt="image"></p>
<p><strong>带上礼物，和心爱的人穿戴整齐，一起回家里看看爸妈。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/619406bd3a99447abe2b8a97683272e3_th.jpg" alt="image"></p>
<p><strong>一台缝纫机，一辆自行车，一台收音机，加上母亲准备的花棉被，就是全部的嫁妆。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/3066796109054dceb217c06419be6b37_th.jpg" alt="image"></p>
<p><strong>那个年代，爱情有着纯粹的颜色，神圣不容亵渎。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/94a5274509284b209227b242f4088d06_th.jpg" alt="image"></p>
<p><strong>那个年代，车马很慢，书信很远，一生只够爱一人。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/a1120031cd624a76a3887f1b26bdb7eb_th.jpg" alt="image"></p>
<p><strong>30年前的我爱你，不是嘴上说说，</strong></p>
<p><strong>而是用一生的时光去守护你！</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/bf016bb8559c4e4aae0a8e101ba191d3_th.jpg" alt="image"></p>
<hr>
<blockquote>
<p>“两姓联姻，一堂缔约，良缘永结，匹配同称。看此日桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。谨以白头之约，书向鸿笺，好将红叶之盟，载明鸳谱。此证。” </p>
<p>张爱玲说过：“于千万人之中遇见你所要遇见的人,于千万年之中,时间的无涯的荒野里,没有早一步,也没有晚一步,刚巧赶上了,没有别的话可说,唯有轻轻地问一声:“原来你也在这里 ”</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天听电台上逛到了这篇文章，首先想到的应该是爸妈那一代人，是我们比较熟悉的，那缝纫机，我家里现在还能用了；我小时候学习骑车的时候，用的就是当初爸妈结婚的时候自行车；还有当时的小彩电，被我拿来打游戏机了……现在想起来，惭愧的很，没能好好珍惜，那是属于父母的美好记忆的一部分。当
    
    </summary>
    
      <category term="分享" scheme="http://blog.wuwii.com/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="故事" scheme="http://blog.wuwii.com/tags/%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Easyui异步ComboTree加载到指定子节点展开</title>
    <link href="http://blog.wuwii.com/easyui-combotree.html"/>
    <id>http://blog.wuwii.com/easyui-combotree.html</id>
    <published>2017-11-22T15:08:03.000Z</published>
    <updated>2017-11-22T14:41:00.189Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Easyui异步ComboTree加载到指定子节点展开</strong>，其实以为这个功能会很简单，做起来出了一些问题，现在做完了，也还是存在一些隐患，记录，等找到最好的解决办法：</p>
<a id="more"></a>
<h4 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h4><p>业务其实是一个很普通的省市县的级联查询，但是，我们不是那个一级一级的方式选择的，是直接加载一棵树，在到树下一级一级的选到想要的位置。</p>
<p>主要就是加载异步树，还有就是去加载到当前指定的子节点上，并且打开每一级的父节点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;测试玩&lt;<span class="regexp">/title&gt;</span></div><div class="line"><span class="regexp">    &lt;link rel="stylesheet" href="../</span>../theme/<span class="keyword">default</span>/easyui.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;link rel="</span>stylesheet<span class="string">" type="</span>text/css<span class="string">" href="</span>../../theme/icon.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;link rel="</span>stylesheet<span class="string">" type="</span>text/css<span class="string">" href="</span>../../css/app.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;link rel="</span>stylesheet<span class="string">" type="</span>text/css<span class="string">" href="</span>../../css/main.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;link rel="</span>stylesheet<span class="string">" type="</span>text/css<span class="string">" href="</span>../../css/icon.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">" src="</span>../../js/jquery.min.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">" src="</span>../../js/jquery.easyui.min.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">" src="</span>../../js/easyui-lang-zh_CN.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">&lt;/head&gt;</span></div><div class="line"><span class="string">&lt;body&gt;</span></div><div class="line"><span class="string">&lt;input id="</span>tree<span class="string">"/&gt;</span></div><div class="line"><span class="string">&lt;!--测试使用打开到指定的子节点--&gt;</span></div><div class="line"><span class="string">&lt;a id="</span>expand<span class="string">"&gt;指定打开&lt;/a&gt;</span></div><div class="line"><span class="string">&lt;script type="</span>text/javascript<span class="string">"&gt;</span></div><div class="line"><span class="string">    /**</span></div><div class="line"><span class="string">     * 后台服务url自己修改成配置文件的</span></div><div class="line"><span class="string">     */</span></div><div class="line"><span class="string">    var baseUrl = "</span>http:<span class="comment">//192.168.19.207:8081/devframe-server/";</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 记录级联信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">var</span> selectNode = &#123;</div><div class="line">        province: <span class="literal">null</span>,</div><div class="line">        city: <span class="literal">null</span>,</div><div class="line">        county: <span class="literal">null</span>,</div><div class="line">        town: <span class="literal">null</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据type判断级联</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">var</span> nodeType = &#123;</div><div class="line">        province: <span class="string">'province'</span>,</div><div class="line">        city: <span class="string">'city'</span>,</div><div class="line">        county: <span class="string">'county'</span>,</div><div class="line">        town: <span class="string">'town'</span></div><div class="line">    &#125;</div><div class="line">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        initComboTree();</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 初始化ComboTree</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initComboTree</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//第一次加载成功需要选中高亮第一个节点</span></div><div class="line">        <span class="keyword">var</span> isHighlight = <span class="literal">true</span>;</div><div class="line">        $(<span class="string">"#tree"</span>).combotree(&#123;</div><div class="line">            method: <span class="string">"post"</span>,</div><div class="line">            url: baseUrl + <span class="string">'dictionary/asyncdata/canton'</span>,</div><div class="line">            panelWidth: <span class="string">'170'</span>,</div><div class="line">            onClick: <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">                getNodeMessage(node);</div><div class="line">            &#125;,</div><div class="line">            onBeforeExpand: <span class="function"><span class="keyword">function</span> (<span class="params">node, param</span>) </span>&#123;</div><div class="line">                $(<span class="keyword">this</span>).tree(<span class="string">'options'</span>).url = baseUrl + <span class="string">'dictionary/asyncdata/canton?id='</span> + node.id;</div><div class="line">            &#125;,</div><div class="line">            onLoadSuccess: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (!isHighlight) <span class="keyword">return</span>;</div><div class="line">                $(<span class="string">"#tree li:eq(0)"</span>).find(<span class="string">"div"</span>).addClass(<span class="string">"tree-node-selected"</span>);</div><div class="line">                <span class="keyword">var</span> n = $(<span class="keyword">this</span>).tree(<span class="string">"getSelected"</span>);</div><div class="line">                <span class="keyword">if</span> (n != <span class="literal">null</span>) $(<span class="keyword">this</span>).tree(<span class="string">"select"</span>, n.target);</div><div class="line">                isHighlight = <span class="literal">false</span>;</div><div class="line">            &#125;,</div><div class="line">            loadFilter: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">                data = data.data;</div><div class="line">                <span class="comment">//不要问为什么有这么一步，因为懒，不想改服务</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="string">'data'</span> <span class="keyword">in</span> data[i]) &#123;</div><div class="line">                        data[i].text = data[i].data;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> data;</div><div class="line">            &#125;,</div><div class="line">            formatter: <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (!node.children || node.children.length == <span class="number">0</span>) <span class="keyword">return</span> node.text;</div><div class="line">                <span class="keyword">return</span> node.text + <span class="string">'&lt;span style="color:blue"&gt;('</span> + node.children.length + <span class="string">')&lt;/span&gt;'</span>;</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">//屏蔽浏览器默认的右键事件，改为和左键点击事件一样的了</span></div><div class="line">            onContextMenu: <span class="function"><span class="keyword">function</span> (<span class="params">e, node</span>) </span>&#123;</div><div class="line">                e.preventDefault();</div><div class="line">                $(<span class="keyword">this</span>).tree(<span class="string">'select'</span>, node.target);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 编辑状态中的树，需要展开到指定节点</span></div><div class="line"><span class="comment">     * @param id 需要展开的Id</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">editComboTree</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            type: <span class="string">'post'</span>,</div><div class="line">            url: baseUrl + <span class="string">'dictionary/expandto/'</span> + id,</div><div class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (response == <span class="literal">null</span> || response.statusCode == <span class="number">400</span>) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                $(<span class="string">"#tree"</span>).combotree(<span class="string">'loadData'</span>, response);</div><div class="line">                $(<span class="string">"#tree"</span>).combotree(<span class="string">'setValue'</span>, id);</div><div class="line">            &#125;,</div><div class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">                <span class="comment">//TODO error</span></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 点击树，获取级联的信息</span></div><div class="line"><span class="comment">     * @param node 节点</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNodeMessage</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> remark = node.type;</div><div class="line">        <span class="keyword">if</span> (remark == <span class="literal">null</span> || remark == <span class="string">""</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remark == nodeType.province) &#123;</div><div class="line">            selectNode.province = node.text;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remark == nodeType.city) &#123;</div><div class="line">            selectNode.city = node.text;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remark == nodeType.county) &#123;</div><div class="line">            selectNode.county = node.text;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remark == nodeType.town) &#123;</div><div class="line">            selectNode.town = node.text;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//查找父级节点，没有则退出</span></div><div class="line">        <span class="keyword">var</span> parent = getParentNode(node);</div><div class="line">        <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</div><div class="line">            getNodeMessage(parent)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据节点获取父节点</span></div><div class="line"><span class="comment">     * @param node 节点</span></div><div class="line"><span class="comment">     * @returns &#123;*&#125; 父节点</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getParentNode</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> tree = $(<span class="string">'#tree'</span>).combotree(<span class="string">'tree'</span>);</div><div class="line">        <span class="keyword">return</span> tree.tree(<span class="string">'getParent'</span>, node.target);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//测试的，打开到指定的子节点，点击事件</span></div><div class="line">    $(<span class="string">"#expand"</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        editComboTree(<span class="string">'431000000000'</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>body&gt;</div><div class="line">&lt;<span class="regexp">/html&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><p>服务端有点差，就不贴代码了，说下解决思路。</p>
<ul>
<li>持久层框架：JPA</li>
<li>数据库：PostgreSQL<h5 id="加载异步树的服务"><a href="#加载异步树的服务" class="headerlink" title="加载异步树的服务"></a>加载异步树的服务</h5>主要是利用了SQL，对，使用原生SQL查的。这里还有一个问题，就是easyui的ComboTree加载异步树的时候，需要判断当前查询出来的节点下面还有没有子节点，就是我们平常看到树的前面有一个尖三角符号，用来表示是否能展开。<br>ComboTree同时继承了Combo和Tree两个的特点，其实，就是把数据绑定到tree上，tree的节点（node）有一个属性是<code>state</code>，用来控制树的该节点的展开与否，它有两个值：<code>open</code>和<code>closed</code>，所以查询的时候干脆就直接的查出了这个属性，SQL有些特别：</li>
</ul>
<p>condition参数是接到WHERE后面的查询条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AtomicReference&lt;String&gt; sql = new AtomicReference&lt;&gt;(&quot;SELECT T.*,CASE WHEN T1.\&quot;COUNT\&quot;=0 OR &quot; +</div><div class="line">               &quot;T1.\&quot;COUNT\&quot; IS NULL THEN &apos;open&apos; WHEN T1.\&quot;COUNT\&quot;&gt;0 THEN &apos;closed&apos; END AS \&quot;STATE\&quot; &quot; +</div><div class="line">               &quot;FROM(SELECT * FROM \&quot;DEV_DICTIONARY\&quot; WHERE &quot; + condition.get() +</div><div class="line">               &quot; ORDER BY \&quot;PARENTID\&quot;) T LEFT JOIN (SELECT \&quot;PARENTID\&quot;, COUNT(\&quot;PARENTID\&quot;) \&quot;COUNT\&quot; FROM \&quot;DEV_DICTIONARY\&quot; &quot; +</div><div class="line">               &quot;WHERE \&quot;PARENTID\&quot; IN (SELECT \&quot;ID\&quot; FROM \&quot;DEV_DICTIONARY\&quot; WHERE &quot; + condition.get() + &quot;) &quot; +</div><div class="line">               &quot;GROUP BY \&quot;PARENTID\&quot;) T1 ON T.\&quot;ID\&quot; = T1.\&quot;PARENTID\&quot;&quot;);</div></pre></td></tr></table></figure></p>
<p>这样太难看了，最后娶一个实例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">        T.*,</div><div class="line">        <span class="keyword">CASE</span> </div><div class="line">            <span class="keyword">WHEN</span> T1.<span class="string">"COUNT"</span>=<span class="number">0</span> </div><div class="line">            <span class="keyword">OR</span> T1.<span class="string">"COUNT"</span> <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">'open'</span> </div><div class="line">            <span class="keyword">WHEN</span> T1.<span class="string">"COUNT"</span>&gt;<span class="number">0</span> <span class="keyword">THEN</span> <span class="string">'closed'</span> </div><div class="line">        <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">"STATE"</span> </div><div class="line">    <span class="keyword">FROM</span></div><div class="line">        (<span class="keyword">SELECT</span></div><div class="line">            * </div><div class="line">        <span class="keyword">FROM</span></div><div class="line">            <span class="string">"DEV_DICTIONARY"</span> </div><div class="line">        <span class="keyword">WHERE</span></div><div class="line">            <span class="string">"TYPE"</span>=<span class="string">'canton'</span> </div><div class="line">            <span class="keyword">AND</span> <span class="string">"PARENTID"</span> <span class="keyword">is</span> <span class="literal">null</span> </div><div class="line">            </div><div class="line">                    <span class="keyword">ORDER</span> <span class="keyword">BY</span></div><div class="line">                        <span class="string">"PARENTID"</span></div><div class="line">                ) T </div><div class="line">            <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></div><div class="line">                (</div><div class="line">                    <span class="keyword">SELECT</span></div><div class="line">                        <span class="string">"PARENTID"</span>,</div><div class="line">                        <span class="keyword">COUNT</span>(<span class="string">"PARENTID"</span>) <span class="string">"COUNT"</span> </div><div class="line">                    <span class="keyword">FROM</span></div><div class="line">                        <span class="string">"DEV_DICTIONARY"</span> </div><div class="line">                    <span class="keyword">WHERE</span></div><div class="line">                        <span class="string">"PARENTID"</span> <span class="keyword">IN</span> (</div><div class="line">                            <span class="keyword">SELECT</span></div><div class="line">                                <span class="string">"ID"</span> </div><div class="line">                            <span class="keyword">FROM</span></div><div class="line">                                <span class="string">"DEV_DICTIONARY"</span> </div><div class="line">                            <span class="keyword">WHERE</span></div><div class="line">                                <span class="string">"TYPE"</span>=<span class="string">'canton'</span> </div><div class="line">                                <span class="keyword">AND</span> <span class="string">"PARENTID"</span> <span class="keyword">is</span> <span class="literal">null</span> )</div><div class="line">                            <span class="keyword">GROUP</span> <span class="keyword">BY</span></div><div class="line">                                <span class="string">"PARENTID"</span></div><div class="line">                        ) T1 </div><div class="line">                            <span class="keyword">ON</span> T.<span class="string">"ID"</span> = T1.<span class="string">"PARENTID"</span></div></pre></td></tr></table></figure></p>
<p>这样查询出来的就多了一列state，按照是否有子集，设置它是closed 还是open。</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171122215405.png" alt="image"></p>
<p>当然还需要到实体类上去映射好这个属性字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Column(name = &quot;\&quot;STATE\&quot;&quot;)</div><div class="line">private String state;</div></pre></td></tr></table></figure></p>
<h5 id="加载到指定节点"><a href="#加载到指定节点" class="headerlink" title="加载到指定节点"></a>加载到指定节点</h5><p>加载到指定节点，并展开到该节点。这个就用脑图说下思路吧。暂时我感觉我的做法不是很好，我看能不能减少复杂度，期待以后能解决，看到的朋友如果有好的解决办法，请与我联系，万分感谢。<br><img src="http://ov62kaxkk.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171122221203.png" alt="image"></p>
<p>其实我们需要找到的数据就是这样的一组数据：<br>首先找到同级的，再去找父的，父的又去找自己的同级，再去找自己的上一级。。。直到找到root节点，完毕。</p>
<p>我是分步做的，应该有更少步骤或者一条SQL完成的，下去研究，估计有点难。</p>
<h4 id="展示下结果吧"><a href="#展示下结果吧" class="headerlink" title="展示下结果吧"></a>展示下结果吧</h4><p>异步树：<br><img src="http://ov62kaxkk.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171122221612.png" alt="image"></p>
<p>展示到指定节点效果:</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171122221552.png" alt="image"></p>
<p>还要注意一点，就是请求服务使用get会好些，get比post快，但是要加上时间戳，避免去读取浏览器缓存数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Easyui异步ComboTree加载到指定子节点展开&lt;/strong&gt;，其实以为这个功能会很简单，做起来出了一些问题，现在做完了，也还是存在一些隐患，记录，等找到最好的解决办法：&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="easyui" scheme="http://blog.wuwii.com/tags/easyui/"/>
    
      <category term="Web前端" scheme="http://blog.wuwii.com/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>《小王子》读后感</title>
    <link href="http://blog.wuwii.com/princekin.html"/>
    <id>http://blog.wuwii.com/princekin.html</id>
    <published>2017-11-21T15:08:03.000Z</published>
    <updated>2017-11-21T15:27:59.752Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>从前呀，有一位小王子，他住在同自己差不多大的星球上，他想要一位朋友。</p>
</blockquote>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/timg.jpg" alt="image"></p>
<p>平时比较忙，如果说读小说的话时间太长了，还有很多专业的书没看，弄得半年都过去了《飘》都没看完，说句老实话，我是个不喜欢读书的人/。。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>然而他却放佛面对意见很严肃的事情，第二次从容迫不及待的对我说：“请为了画只羊。”</p>
</blockquote>
<p>这句话应该很经典，这也是故事中羊的由来，故事中的我从未划过羊，内心其实是很害怕的，其实看得多才知道，为什么会有羊这个片段，说到底就是年少的单纯吧，让羊去啃那个面包树；但是也有可能是追求善良吧，个人理解。</p>
<blockquote>
<p>忘记一位朋友，这真使人悲哀。并非每个人都有过一位朋友。</p>
</blockquote>
<p>这段话真是揪心啊，与朋友一起是一个很快乐的事情，但是想忘记一个人真的很痛苦吧，也许有一天，会慢慢淡忘一个人。但是在当前岁月下，好好珍惜身边的每一个爱你和你爱的人。现在，买得起充电五分钟的手机，但是通话两小时的人可不好找。</p>
<blockquote>
<p>猴面包树在长大以前也是很小的。</p>
</blockquote>
<p>小王子在知道羊吃小灌木的时候，他很开心，它们可以吃猴面包树了，但是猴面包树已经长得很大，羊可吃不了，只有在它小的时候，才能警惕它。孩子们，要当心那些猴面包树呀！<br>猴面包树是人们都不想要的东西，想放弃的东西，但是，人们是自私的，想放下，却不想放下，但是自己又不甘放下那段执念，明知结果不好，确实还是贪婪的霸占着这一片不属于你的土地，最好确是还是一步一步越陷越深。所以要在开始有这种心理的时候就要把它铲除掉，找到自己的玫瑰，将它种下，在心中发芽，这样心中才能充满美好。</p>
<blockquote>
<p>你知道，当感到十分愁闷的时候，人们都会想看太阳落山。</p>
</blockquote>
<p>小王子一天能看四十三次日出，那是多么忧郁的生活啊，也许唯一的快乐就是看日落，人总是在不知不觉中，感到愁闷，而且是非常糟糕的那种，人为什么会那么难过了。<br>可能是有一种人，就像我吧，总是喜欢把悲伤隐藏的深一点，再深一点，习惯性了都，当然各种事情都有暴露的，比如说，悲伤的时候想看日落，哈哈。说不定高兴的时候就想看日出了。</p>
<blockquote>
<p>星星发亮是为了让每一个人有一天都能找到属于自己的星星。</p>
<p>如果你爱上了某个星球的一朵花。那么，只要在夜晚仰望星空，就会觉得漫天的繁星就像一朵朵盛开的花。</p>
</blockquote>
<p>当在一个地方存在某种特殊意义的时候，不管是什么它将都是独一无二的美丽，即便漫长黑夜里，也可以通过光亮寻找到它的位置。<br>玫瑰是简单而且性格敏感的代表，看到它的故事片段，人心都觉得好暖。玫瑰消失后，这段话很感动，也许就是“心中有了想念的人，你便不觉得孤独”的含义，无牵无挂心中空空如也才最是寂寞。对于狐狸来说，也是不会寂寞的。当然也是遗憾的。你要走便走，不要回头，我不会留。</p>
<blockquote>
<p>狐狸说：“对我来说，你只是一个小男孩，就像其他成千上万个小男孩一样没有什么两样。我不需要你。你也不需要我。对你来说，我也只是一只狐狸，和其他成千上万的狐狸没有什么不同。但是，如果你驯养了我，我们就会彼此需要。对我来说，你就是我的世界里独一无二的了；我对你来说，也是你的世界里的唯一了。”<br>一旦你驯服了什么，就要对她负责，永远的负责。</p>
</blockquote>
<p>狐狸告诉了让小王子懂得了生活的本质和爱情的真谛。“一个人被驯服,是冒着流泪的危险的”，“只有用心才能看得清。实质性的东西，用眼睛是看不见的。”<br>用心去看才看得清楚，小王子知道需要珍惜他的玫瑰；爱就是责任。</p>
<blockquote>
<p>Growing up is not the problem.Forgetting is.</p>
</blockquote>
<hr>
<p>一切仅代表个人观点哈，勿喷</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从前呀，有一位小王子，他住在同自己差不多大的星球上，他想要一位朋友。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ov62kaxkk.bkt.clouddn.com/timg.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;平时比较忙，如果说读小说的话时间太长了，还有很多专业的书没看，弄得半年都过去了《飘》都没看完，说句老实话，我是个不喜欢读书的人/。。&lt;/p&gt;
    
    </summary>
    
      <category term="随随便便" scheme="http://blog.wuwii.com/categories/%E9%9A%8F%E9%9A%8F%E4%BE%BF%E4%BE%BF/"/>
    
    
      <category term="小王子" scheme="http://blog.wuwii.com/tags/%E5%B0%8F%E7%8E%8B%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>我的蛋碎了一个</title>
    <link href="http://blog.wuwii.com/20171120.html"/>
    <id>http://blog.wuwii.com/20171120.html</id>
    <published>2017-11-21T14:08:03.000Z</published>
    <updated>2017-11-21T13:29:26.348Z</updated>
    
    <content type="html"><![CDATA[<p>真的。。</p>
<a id="more"></a>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/IMG_20171120_203908.jpg" alt="image"></p>
<p>看到这个蛋，随口喊出那句话，被自己蠢哭了。</p>
<p>支付宝刮了一张卡，感觉到马云爸爸深深的恶意。</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/Screenshot.png" alt="image"></p>
<p>用穷逼会员咋的，</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/u=3069228711,3931262156&amp;fm=27&amp;gp=0.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的。。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>使用Redis完成分布式锁</title>
    <link href="http://blog.wuwii.com/redis-lock.html"/>
    <id>http://blog.wuwii.com/redis-lock.html</id>
    <published>2017-11-20T14:08:03.000Z</published>
    <updated>2017-11-21T12:34:42.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><blockquote>
<p>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>
</blockquote>
<p>为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。</p>
<h4 id="使用Redis实现锁的原因"><a href="#使用Redis实现锁的原因" class="headerlink" title="使用Redis实现锁的原因"></a>使用Redis实现锁的原因</h4><ol>
<li>Redis有很高的性能；</li>
<li>Redis命令对此支持较好，实现起来比较方便。</li>
</ol>
<a id="more"></a>
<h4 id="主要利用到的命令"><a href="#主要利用到的命令" class="headerlink" title="主要利用到的命令"></a>主要利用到的命令</h4><h5 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h5><blockquote>
<p>SETNX key val<br>当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。</p>
</blockquote>
<h5 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h5><p>expire key timeout<br>为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p>delete key<br>删除key</p>
<h4 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h4><ul>
<li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，保证key一致，通过此在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，当前时间小于超时时间，则执行delete进行锁释放。</li>
</ul>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.devframe.util;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * &lt;b&gt;redis分布式锁的实现&lt;/b&gt;&lt;/br&gt;</span></div><div class="line"><span class="comment"> * 还有一些失败机制没处理，以后在使用测试阶段，完善。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/20 9:22&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisLock.class);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * redis连接</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Jedis jedis;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 锁定资源名，锁key，保证唯一。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 资源上锁的最长时间，超时自动解锁单位秒，&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 建议设置成死的，如果设置不当容易影响效率，严重造成死锁。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> expireTime = Integer.valueOf(PropertyUtil.get(<span class="string">"redisLock.expireTime"</span>));</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 线程获取不到锁，休眠的时间，单位ms</span></div><div class="line"><span class="comment">     * 避免系统资源浪费</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sleepTime = Long.valueOf(PropertyUtil.get(<span class="string">"redisLock.sleepTime"</span>));</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当前锁超时的时间戳，单位毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTimeOut = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取锁状态，锁中断状态&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 值为false的时候中断获取锁&lt;/br&gt;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> interrupted = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 构造方法</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jedis    redis连接</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 上锁key，唯一标识</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(Jedis jedis, String lockName)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lockName == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"lockName is required"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.jedis = jedis;</div><div class="line">        <span class="comment">// 重命名的前缀，可以不加，也可以自定义，保证唯一即可。</span></div><div class="line">        <span class="keyword">this</span>.lockName = <span class="string">"lock"</span> + lockName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取锁。如果锁已被其他线程获取，则进行等待，直到拿到锁为止。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.lockCheck();</div><div class="line">            <span class="keyword">long</span> id = jedis.setnx(lockName, lockName);</div><div class="line">            <span class="keyword">if</span> (id == <span class="number">0L</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">/**</span></div><div class="line"><span class="comment">                     * 没有获取到锁则进行等待睡眠时间，再去重新获取锁&lt;/br&gt;</span></div><div class="line"><span class="comment">                     * 这里使用随机时间可能会好一点,可以防止饥饿进程的出现,即,当同时到达多个进程,</span></div><div class="line"><span class="comment">                     * 只会有一个进程获得锁,其他的都用同样的频率进行尝试,后面有来了一些进行,</span></div><div class="line"><span class="comment">                     * 也以同样的频率申请锁,这将可能导致前面来的锁得不到满足.</span></div><div class="line"><span class="comment">                     * 使用随机的等待时间可以一定程度上保证公平性</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">                    Thread.sleep(<span class="keyword">this</span>.sleepTime);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    logger.error(<span class="string">"Thread is interrupted"</span>, e);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                expireTimeOut = System.currentTimeMillis() + expireTimeOut * <span class="number">1000</span> + <span class="number">1</span>;</div><div class="line">                <span class="comment">//设置redis中key的过期时间</span></div><div class="line">                jedis.expire(<span class="keyword">this</span>.lockName, expireTime);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 中断锁获取</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 中断异常</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.interrupted = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 它表示用来尝试获取锁，会立即返回，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lockCheck();</div><div class="line">        <span class="comment">//尝试获取锁</span></div><div class="line">        <span class="keyword">long</span> id = jedis.setnx(lockName, lockName);</div><div class="line">        <span class="comment">//返回结果为0 则已经存在key，已经存在锁。</span></div><div class="line">        <span class="keyword">if</span> (id == <span class="number">0L</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            expireTimeOut = System.currentTimeMillis() + expireTimeOut * <span class="number">1000</span> + <span class="number">1</span>;</div><div class="line">            <span class="comment">//设置redis中key的过期时间</span></div><div class="line">            jedis.expire(<span class="keyword">this</span>.lockName, expireTime);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。&lt;/br&gt;</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> time 等待时间</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 中断异常</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"TimeUnit is required."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> timeOutAt = now + calcSeconds(time, unit);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.lockCheck();</div><div class="line">            <span class="keyword">long</span> id = jedis.setnx(<span class="keyword">this</span>.lockName, <span class="keyword">this</span>.lockName);</div><div class="line">            <span class="comment">// id = 0 表示加锁失败</span></div><div class="line">            <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 获取锁超时</span></div><div class="line">                <span class="keyword">if</span> (System.currentTimeMillis() &gt; timeOutAt) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 休眠一段时间，线程再继续获取锁。</span></div><div class="line">                Thread.sleep(<span class="keyword">this</span>.sleepTime);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//获取锁成功，设置锁过期时间戳</span></div><div class="line">                expireTimeOut = System.currentTimeMillis() + expireTimeOut * <span class="number">1000</span> + <span class="number">1</span>;</div><div class="line">                jedis.expireAt(<span class="keyword">this</span>.lockName, expireTimeOut);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * &lt;b&gt;释放锁&lt;b/&gt;</span></div><div class="line"><span class="comment">     * 当前时间小于过期时间，则锁未超时，删除锁，&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 过了超时时间，redis已经删除了该key。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &lt; expireTimeOut) &#123;</div><div class="line">            jedis.del(lockName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//TODO 涉及到 Condition 例外一个重要内容，以后再实现这个方法</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"did not supported."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 检查当前线程资源redis连接和锁的状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockCheck</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (jedis == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Jedis is required."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!interrupted) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Thread is interrupted."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * TimeUnit单位时间转换成毫秒</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> long</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">calcSeconds</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.DAYS) &#123;</div><div class="line">            <span class="keyword">return</span> time * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.HOURS) &#123;</div><div class="line">            <span class="keyword">return</span> time * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.MINUTES) &#123;</div><div class="line">            <span class="keyword">return</span> time * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.SECONDS) &#123;</div><div class="line">            <span class="keyword">return</span> time * <span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.MILLISECONDS) &#123;</div><div class="line">            <span class="keyword">return</span> time;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//后面的不实现了，基本上用不到。</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"cannot be resolved."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># redis lock</div><div class="line"># s</div><div class="line">redisLock.expireTime=1</div><div class="line"># ms</div><div class="line">redisLock.sleepTime=100</div></pre></td></tr></table></figure></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试就选用最经典的秒杀系统吧，使用分布式锁可以控制资源。</p>
<p>下面模拟500人秒杀100件商品。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.devframe.util;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/20 14:12&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockTest</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 100件物品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> goodsNum = <span class="number">100</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 500人</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> personNum = <span class="number">500</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 不加锁的情况</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personNum; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">if</span> (goodsNum &gt; <span class="number">0</span>) &#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取了锁"</span>);</div><div class="line">                    System.out.println(<span class="string">"商品剩余："</span> + --goodsNum);</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 加上分布锁</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personNum; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                Jedis jedis = RedisUtil.getJedis();</div><div class="line">                <span class="comment">//初始化锁，key保持一致</span></div><div class="line">                Lock lock = <span class="keyword">new</span> RedisLock(jedis, <span class="string">"aa"</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock.lock();</div><div class="line">                    <span class="keyword">if</span> (goodsNum &gt; <span class="number">0</span>) &#123;</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"获取了锁"</span>);</div><div class="line">                        System.out.println(<span class="string">"商品剩余："</span> + --goodsNum);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不加锁的部分结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Thread-100获取了锁</div><div class="line">商品剩余：-3</div><div class="line">Thread-99获取了锁</div><div class="line">商品剩余：5</div><div class="line">商品剩余：6</div><div class="line">Thread-98获取了锁</div><div class="line">商品剩余：-5</div><div class="line">商品剩余：7</div><div class="line">商品剩余：-4</div><div class="line">商品剩余：0</div><div class="line">商品剩余：1</div><div class="line">Thread-105获取了锁</div><div class="line">商品剩余：-6</div></pre></td></tr></table></figure></p>
<p>上锁的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Thread-8获取了锁</div><div class="line">商品剩余：5</div><div class="line">Thread-238获取了锁</div><div class="line">商品剩余：4</div><div class="line">Thread-72获取了锁</div><div class="line">商品剩余：3</div><div class="line">Thread-137获取了锁</div><div class="line">商品剩余：2</div><div class="line">Thread-402获取了锁</div><div class="line">商品剩余：1</div><div class="line">Thread-337获取了锁</div><div class="line">商品剩余：0</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>并发量大的时候，需要考虑锁时间；</li>
<li>考虑失败情况，上锁了，但是设置超时时间失败（redis崩溃等各种情况），锁一致都没有释放，导致死锁的情况发生，现在需要做的是，把key的value设置成超时的时间，每次上锁失败都去检查一次，超时的就覆盖，可以避免死锁。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。&lt;/p&gt;
&lt;h4 id=&quot;使用Redis实现锁的原因&quot;&gt;&lt;a href=&quot;#使用Redis实现锁的原因&quot; class=&quot;headerlink&quot; title=&quot;使用Redis实现锁的原因&quot;&gt;&lt;/a&gt;使用Redis实现锁的原因&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Redis有很高的性能；&lt;/li&gt;
&lt;li&gt;Redis命令对此支持较好，实现起来比较方便。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
      <category term="redis" scheme="http://blog.wuwii.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字解析</title>
    <link href="http://blog.wuwii.com/java-volatile.html"/>
    <id>http://blog.wuwii.com/java-volatile.html</id>
    <published>2017-11-19T03:58:03.000Z</published>
    <updated>2017-11-20T07:52:27.522Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h3><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<a id="more"></a>
<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = i + 1;</div></pre></td></tr></table></figure></p>
<p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<ol>
<li>通过在总线加LOCK#锁的方式；</li>
<li>通过缓存一致性协议。</li>
</ol>
<p>这2种方式都是硬件层面上提供的方式。</p>
<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/212219343783699.jpg" alt="image"></p>
<h3 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h3><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>一个很经典的例子就是银行账户转账问题：</p>
<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>同样地反映到并发编程中会出现什么结果呢？<br>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = 9;</div></pre></td></tr></table></figure></p>
<p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。<br>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//线程1执行的代码</div><div class="line">int i = 0;</div><div class="line">i = 10;</div><div class="line"> </div><div class="line">//线程2执行的代码</div><div class="line">j = i;</div></pre></td></tr></table></figure></p>
<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 <code>j = i</code>，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int i = 0;              </div><div class="line">boolean flag = false;</div><div class="line">i = 1;                //语句1  </div><div class="line">flag = true;          //语句2</div></pre></td></tr></table></figure></p>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 10;    //语句1</div><div class="line">int r = 2;    //语句2</div><div class="line">a = a + 3;    //语句3</div><div class="line">r = a*a;     //语句4</div></pre></td></tr></table></figure></p>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/212305263939989.jpg" alt="image"></p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();   <span class="comment">//语句1</span></div><div class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p> 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i  = 10;</div></pre></td></tr></table></figure>
<p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h4 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h4><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = 10;         //语句1</div><div class="line">y = x;         //语句2</div><div class="line">x++;           //语句3</div><div class="line">x = x + 1;     //语句4</div></pre></td></tr></table></figure>
<p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h4 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h4><p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h4 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h4><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p><strong>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</strong></p>
<p>下面就来具体介绍下<code>happens-before</code>原则（先行发生原则）：</p>
<ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li>
</ol>
<p>这8条原则摘自《深入理解Java虚拟机》。</p>
<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>下面我们来解释一下前4条规则：<br>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h3 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h3><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<h4 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h4><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ol>
<p>先看一段代码，假如线程1先执行，线程2后执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1</span></div><div class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">while</span>(!stop)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//线程2</span></div><div class="line">stop = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是用volatile修饰之后就变得不一样了：</p>
<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程1读取到的就是最新的正确的值。</p>
<h4 id="volatile保证原子性吗？"><a href="#volatile保证原子性吗？" class="headerlink" title="volatile保证原子性吗？"></a>volatile保证原子性吗？</h4><p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，</p>
<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>把上面的代码改成以下任何一种都可以达到效果：</p>
<ol>
<li><p>采用synchronized：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>采用Lock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inc++;</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>采用AtomicInteger：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  AtomicInteger inc = <span class="keyword">new</span> AtomicInteger();</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc.getAndIncrement();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在java 1.5的<code>java.util.concurrent.atomic</code>包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<h4 id="volatile能保证有序性吗？"><a href="#volatile能保证有序性吗？" class="headerlink" title="volatile能保证有序性吗？"></a>volatile能保证有序性吗？</h4><p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<ol>
<li>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li>
</ol>
<p>可能上面说的比较绕，举个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//x、y为非volatile变量</div><div class="line">//flag为volatile变量</div><div class="line"> </div><div class="line">x = 2;        //语句1</div><div class="line">y = 0;        //语句2</div><div class="line">flag = true;  //语句3</div><div class="line">x = 4;         //语句4</div><div class="line">y = -1;       //语句5</div></pre></td></tr></table></figure></p>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面举的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//线程1:</div><div class="line">context = loadContext();   //语句1</div><div class="line">inited = true;             //语句2</div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h4 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h4><p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>下面这段话摘自《深入理解Java虚拟机》：</p>
<blockquote>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
</blockquote>
<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<ol>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>
<h3 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h3><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<ol>
<li>对变量的写操作不依赖于当前值；</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ol>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<h4 id="状态标记量"><a href="#状态标记量" class="headerlink" title="状态标记量"></a>状态标记量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"> </div><div class="line"><span class="keyword">while</span>(!flag)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</div><div class="line">    flag = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();  </div><div class="line">inited = <span class="keyword">true</span>;            </div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<h4 id="double-check"><a href="#double-check" class="headerlink" title="double check"></a>double check</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于为何需要这么写请参考：<br>《Java 中的双重检查（Double-Check）》<br><a rel="external nofollow" target="_blank" href="http://blog.csdn.net/dl88250/article/details/5439024">http://blog.csdn.net/dl88250/article/details/5439024</a><br><a rel="external nofollow" target="_blank" href="http://www.iteye.com/topic/652440">http://www.iteye.com/topic/652440</a></p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p><strong>文章转载<a rel="external nofollow" target="_blank" href="http://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a></strong></p>
<h3 id="最后附上自己的学习代码"><a href="#最后附上自己的学习代码" class="headerlink" title="最后附上自己的学习代码"></a>最后附上自己的学习代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.wuwii.test.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/18 9:20&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc1;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc2;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 并发中不适用int， 使用jdk1.5的原子操作类</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> AtomicInteger inc3 = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 自增，不保证原子性</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用synchronized保证原子性</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase1</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc1++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用Lock保证原子性</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increase2</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inc2++;</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用jdk1.5的原子操作类，保证原子性</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increase3</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc3.getAndIncrement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取系统运行默认线程数，理论上只有一条主线程，需要注意的是，但是在idea上中默认多了一个monitor ctrlbreak线程。</span></div><div class="line">        <span class="comment">// 可参考 http://blog.csdn.net/xiaolinzi007/article/details/44487851</span></div><div class="line">        <span class="keyword">int</span> defaultActiveCount = Thread.activeCount();</div><div class="line">        <span class="keyword">int</span> threadCount = <span class="number">10</span>;</div><div class="line">        <span class="keyword">int</span> increaseCount = <span class="number">1000</span>;</div><div class="line">        <span class="keyword">final</span> VolatileTest test = <span class="keyword">new</span> VolatileTest();</div><div class="line">        <span class="comment">// 创建10个线程，分别自增1000次。</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; increaseCount; i1++) &#123;</div><div class="line">                    test.increase();</div><div class="line">                    test.increase1();</div><div class="line">                    test.increase2();</div><div class="line">                    test.increase3();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//保证前面的线程都执行完。</span></div><div class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; defaultActiveCount) &#123;</div><div class="line">           Thread.yield();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 打印最终结果，理论结果10 * 1000 = 10000。</span></div><div class="line">        System.out.printf(<span class="string">"自增后inc为：%d%n"</span>, test.inc);</div><div class="line">        System.out.printf(<span class="string">"自增后inc1为：%d%n"</span>, test.inc1);</div><div class="line">        System.out.printf(<span class="string">"自增后inc2为：%d%n"</span>, test.inc2);</div><div class="line">        System.out.printf(<span class="string">"自增后inc3为：%d%n"</span>, test.inc3.get());</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 状态标记，利用volatile可见性属性，保持线程有序执行</span></div><div class="line"><span class="comment">         * &lt;p&gt;写一个线程做完事情后将标记赋值true，线程二一直阻塞标记为true时执行&lt;p/&gt;</span></div><div class="line"><span class="comment">         */</span></div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">3000</span>);</div><div class="line">                FlagTest.flag = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (!FlagTest.flag) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.out.printf(<span class="string">"%s s后flag改为true%n"</span>, <span class="number">3</span> - i);</div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    i++;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.printf(<span class="string">"flag为true 了"</span>);</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 使用volatile场景&lt;/br&gt;</span></div><div class="line"><span class="comment"> * 1. 状态标记量: 并发时候保证程序按照有序运行&lt;/br&gt;</span></div><div class="line"><span class="comment"> * 2. double check：并发中为了减少同步的开销，于是有了双重检查模式。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlagTest</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * 状态标记量</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 双重检查单例模式</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> FlagTest instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FlagTest</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 双重检查double check</span></div><div class="line"><span class="comment">     * &lt;p&gt;并发情况下为了减少同步的开销，于是有了双重检查模式。&lt;/p&gt;</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> FlagTest</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FlagTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (FlagTest.class) &#123;</div><div class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</div><div class="line">                    instance = <span class="keyword">new</span> FlagTest();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">自增后inc为：9996</div><div class="line">自增后inc1为：10000</div><div class="line">自增后inc2为：10000</div><div class="line">自增后inc3为：10000</div><div class="line">3 s后flag改为true</div><div class="line">2 s后flag改为true</div><div class="line">1 s后flag改为true</div><div class="line">flag为true</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Java内存模型，原子性，可见性，有序性的理解；</li>
<li>volatile修饰的变量具有什么样的特性：可见性，禁止重排序；</li>
<li>并发中的使用方法和运用场景。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内存模型的相关概念&quot;&gt;&lt;a href=&quot;#内存模型的相关概念&quot; class=&quot;headerlink&quot; title=&quot;内存模型的相关概念&quot;&gt;&lt;/a&gt;内存模型的相关概念&lt;/h3&gt;&lt;p&gt;大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
      <category term="并发编程" scheme="http://blog.wuwii.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>20171117</title>
    <link href="http://blog.wuwii.com/20171117.html"/>
    <id>http://blog.wuwii.com/20171117.html</id>
    <published>2017-11-17T14:08:03.000Z</published>
    <updated>2017-11-21T00:50:48.616Z</updated>
    
    <content type="html"><![CDATA[<p>今天天气可真是差啊，下班后出门骑了辆小黄车，没骑到一百米，雨就下起来，只好放下，毕竟大晚上撑伞骑车不太安全，只好选择去公交车站坐公交把。</p>
<p>我的天，一上公交车，还没坐一站路，堵瞎了，我这人虽然每次都是慢半拍的人，喜欢慢节奏的事情，但是了，堵车我最不喜欢的事情，关键我还坐公交车上。</p>
<p>后来接到一个消息说她被前男友骚扰了，说实话啊，我最讨厌的就是渣男了，但是还是要注意形象，去安慰下把，我也是搞不懂状况啊，多了不写了，就是堵了半个小时下车了，准备去她学校看看吧，这路人都不让走的，车一辆接一辆的。终于换车后，堵了一会儿，接到消息说她要回家了，长吁一口气了，其实我挺害怕的，但是听到消息的第一刻就是想到江歌案，所以我才想赶过去，不想写下去了，其实女孩子追到被逼回家了的，这也太可恶了吧。</p>
<p>搞到很晚才回，想到去拿快递，不错，居然没关门，拿回来一看，打开快递，没看码子，拆开试穿了一下，我的妈啊，这么大，我买的衣服全发成大码了，只能去实体店换了，（牌子就不暴露了，好坑。</p>
<p>今天下个班，搞得好累啊，好好睡个觉，明天周六上午还要去公司培训。</p>
<p>晚安/。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天天气可真是差啊，下班后出门骑了辆小黄车，没骑到一百米，雨就下起来，只好放下，毕竟大晚上撑伞骑车不太安全，只好选择去公交车站坐公交把。&lt;/p&gt;
&lt;p&gt;我的天，一上公交车，还没坐一站路，堵瞎了，我这人虽然每次都是慢半拍的人，喜欢慢节奏的事情，但是了，堵车我最不喜欢的事情，关
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 中HashMap源码分析</title>
    <link href="http://blog.wuwii.com/java-hashmap.html"/>
    <id>http://blog.wuwii.com/java-hashmap.html</id>
    <published>2017-11-16T03:08:03.000Z</published>
    <updated>2017-11-16T02:50:03.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap-文档"><a href="#HashMap-文档" class="headerlink" title="HashMap 文档"></a>HashMap 文档</h3><blockquote>
<p>　HashMap是基于哈希表的Map接口实现的,此实现提供所有可选的映射操作。存储的是<code>&lt;key，value&gt;</code>对的映射，允许多个null值和一个null键。但此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br> 　除了HashMap是非同步以及允许使用null外，HashMap 类与 Hashtable大致相同。<br>　 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。</p>
<p>　　HashMap 的实例有两个参数影响其性能：<code>初始容量</code> 和<code>加载因子</code>。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。<strong>加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。</strong>     </p>
<p>　　通常，默认<code>加载因子</code> (0.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。<strong>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</strong><br>　　注意，此实现<code>不是同步</code>的。 如果多个线程同时访问一个HashMap实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。这通常是通过同步那些用来封装列表的 对象来实现的。但如果没有这样的对象存在，则应该使用{@link Collections#synchronizedMap Collections.synchronizedMap}来进行“包装”，该方法最好是在创建时完成，为了避免对映射进行意外的非同步操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap(...));</div></pre></td></tr></table></figure></p>
<p>由所有此类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不会在将来不确定的时间发生任意不确定行为的风险。</p>
<p>注意，迭代器的<code>快速失败</code>行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
</blockquote>
<a id="more"></a>
<p><strong>jdk版本：jdk1.8.0_144</strong></p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组（散列桶）中的每一个元素都是链表。<img src="http://ov62kaxkk.bkt.clouddn.com/hashMap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p>
<h4 id="解决Hash冲突"><a href="#解决Hash冲突" class="headerlink" title="解决Hash冲突"></a>解决Hash冲突</h4><p> HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了<code>链地址法（拉链法）</code>。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。<br> 有时候计算Hash值的时候，会出现相同的情况，这样两个key就存储到相同的位置上了，这个时候会出现<code>Hash碰撞</code>。</p>
<h3 id="HashMap的属性"><a href="#HashMap的属性" class="headerlink" title="HashMap的属性"></a>HashMap的属性</h3><h4 id="实现的接口和继承的类"><a href="#实现的接口和继承的类" class="headerlink" title="实现的接口和继承的类"></a>实现的接口和继承的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>实际上HashMap没有从AbstractMap父亲中继承任何属性，从实现的接口上看，HashMap拥有克隆和序列化的属性。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认初始容量16，必须为2的幂</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"></div><div class="line">    <span class="comment">//最大容量</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line">    <span class="comment">//默认加载因子</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//使用红黑树而不是链表的阈值</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></div><div class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></div><div class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="comment">//table是一个Node&lt;K,V&gt;[]数组类型，而Node&lt;K,V&gt;实际上就是一个元素值为&lt;key,value&gt;对的单向链表。</span></div><div class="line">    <span class="comment">//哈希表的"key-value键值对"都是存储在Node&lt;K,V&gt;数组中的。 </span></div><div class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">    <span class="comment">//用来指向entrySet()返回的set集合</span></div><div class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//HashMap的大小,即保存的键值对的数量</span></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="comment">//用来实现fail-fast机制的，记录HashMap结构化修改的次数</span></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"></div><div class="line">    <span class="comment">//下次需扩容的临界值，size&gt;=threshold就会扩容</span></div><div class="line">    <span class="comment">//如果table数组没有被分配，则该值为初始容量值16；或若该值为0，也表明该值为初始容量值</span></div><div class="line">    <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">    <span class="comment">//加载因子</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>table是一个Node[]数组类型，而Node实际上就是一个单向链表，哈希桶数组。哈希表的”key-value键值对”都是存储在Node数组中的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现Map.Entry&lt;K,V&gt;接口</span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//hash码</span></div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next; <span class="comment">//指向链表中下一个实例</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">            <span class="keyword">this</span>.hash = hash;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</div><div class="line"></div><div class="line">        <span class="comment">//返回此映射项的哈希值:key值的哈希码与value值的哈希码按位异或的结果</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//用指定值替换对应于此项的值,并返回旧值</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">            V oldValue = value;</div><div class="line">            value = newValue;</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//比较指定对象与此项的相等性</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                    Objects.equals(value, e.getValue()))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方，而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p>
<h5 id="loadFactor加载因子"><a href="#loadFactor加载因子" class="headerlink" title="loadFactor加载因子"></a>loadFactor加载因子</h5><p>HashMap的初始化大小length为16（默认值），默认加载因子0.75，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<h5 id="size大小"><a href="#size大小" class="headerlink" title="size大小"></a>size大小</h5><p>HashMap中实际存在的键值对数量。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>HashMap提供了四种方式的构造器，可以构造一个带指定初始容量和加载因子的空HashMap，构造一个带指定初始容量和默认加载因子(0.75)的空 HashMap，构造一个默认初始容量为16和默认加载因子为0.75的空HashMap，以及构造一个包含指定Map的元素的HashMap，容量与指定Map容量相同，加载因子为默认的0.75。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//找出“大于Capacity”的最小的2的幂,使Hash表的容量保持为2的次方倍</span></div><div class="line">    <span class="comment">//算法的思想：通过使用逻辑运算来替代取余，这里有一个规律，就是当N为2的次方（Power of two），那么X％N==X&amp;(N-1)。</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//&gt;&gt;&gt; 无符号右移,高位补0</span></div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">//a|=b的意思就是把a和b按位或然后赋值给a</span></div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构造一个带指定初始容量和加载因子的空HashMap</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                               initialCapacity);</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                               loadFactor);</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构造一个带指定初始容量和默认加载因子(0.75)的空 HashMap</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构造一个具有默认初始容量 (16)和默认加载因子 (0.75)的空 HashMap</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构造一个映射关系与指定 Map相同的新 HashMap,容量与指定Map容量相同，加载因子为默认的0.75</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">        putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h4><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">方法一：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line">方法二：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。<br><img src="http://tech.meituan.com/img/java-hashmap/hashMap%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE.png" alt="image"></p>
<h4 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h4><p>HashMap提供了put(K key, V value)、putAll(Map&lt;? extends K, ? extends V&gt; m)这些添加键值对的方法。<br>HashMap的put方法执行过程可以通过下图来理解，<br><img src="http://ov62kaxkk.bkt.clouddn.com/hashMap%20put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p>
<ol>
<li><p>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
</li>
<li><p>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
</li>
<li><p>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
</li>
<li><p>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
</li>
<li><p>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
</li>
<li><p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
</li>
</ol>
<h5 id="put方法源码"><a href="#put方法源码" class="headerlink" title="put方法源码"></a>put方法源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * 在此映射中关联指定值与指定键。如果该映射以前包含了一个该键的映射关系，则旧值被替换。</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定值将要关联的键</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> value 指定键将要关联的值</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 与 key关联的旧值；如果 key没有任何映射关系，则返回 null。（返回 null 还可能表示该映射之前将null与 key关联。）</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 用于实现 Map.put()和相关的方法</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> hash 键的hash码</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> evict evict=false：表明该hash表处于初始化创建的过程中</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="comment">//步骤 1 ：tab为空则创建  </span></div><div class="line">        <span class="comment">//此处分两种情况：1.当table为null时，用默认容量16初始化table数组；2.当table非空时</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//旧hash表为null或旧hash表长度为0</span></div><div class="line">            n = (tab = resize()).length;  <span class="comment">//初始化hash表的长度（16）</span></div><div class="line">        <span class="comment">//步骤 2</span></div><div class="line">        <span class="comment">//此处又分为两种情况：1.key的hash值对应的那个节点为空；2.key的hash值对应的那个节点不为空</span></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//该key的hash值对应的那个节点为空，即表示还没有元素被散列至此</span></div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//则创建一个新的new Node&lt;&gt;(hash, key, value, next);</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">             <span class="comment">//该key的hash值对应的那个节点不为空，先与链表上的第一个节点p比较</span></div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            <span class="comment">// 步骤 3：节点key存在，直接覆盖value  </span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                e = p;</div><div class="line">                <span class="comment">// 步骤 4：判断该链为红黑树  </span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">            <span class="comment">// 步骤 5：该链为链表 的情况下进行遍历table</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;  </div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理 TREEIFY_THRESHOLD = 8  </span></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// key已经存在的话</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    p = e;  <span class="comment">//向后查找</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//若该key对应的value已经存在，则用新的value取代旧的value</span></div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">                V oldValue = e.value;</div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        <span class="comment">// 步骤 6：如果加入该键值对后超过最大阀值，则进行resize操作 ，就扩容  threshold：</span></div><div class="line">        <span class="comment">//单词解释--阈(yu)值,不念阀(fa)值！顺便学下语文咯。  </span></div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)  </div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//将指定映射的所有映射关系复制到此映射中，这些映射关系将替换此映射目前针对指定映射中所有键的所有映射关系。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        putMapEntries(m, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//用于帮助实现Map.putAll()方法 和Map构造器，当evict=false时表示构造初始HashMap。</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> s = m.size(); <span class="comment">//得到指定Map的大小</span></div><div class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></div><div class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</div><div class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</div><div class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);  <span class="comment">//得到按指定Map大小计算出的HashMap所需的容量</span></div><div class="line">                <span class="keyword">if</span> (t &gt; threshold)  <span class="comment">//如果容量大于阈值</span></div><div class="line">                    threshold = tableSizeFor(t);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)  <span class="comment">//指定Map的大小&gt;扩容临界值,扩容  </span></div><div class="line">                resize();</div><div class="line">            <span class="comment">//通过迭代器，将“m”中的元素逐个添加到HashMap中</span></div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</div><div class="line">                K key = e.getKey();</div><div class="line">                V value = e.getValue();</div><div class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="HashMap的扩容机制resize"><a href="#HashMap的扩容机制resize" class="headerlink" title="HashMap的扩容机制resize"></a>HashMap的扩容机制resize</h4><p>在HashMap的四种构造函数中并没有对其成员变量Node<k,v>[] table进行任何初始化的工作，那么HashMap是如何构造一个默认初始容量为16的空表的？该初始化的诱发条件是在向HashMap中添加第一对<key,value>时，通过<code>put(K key, V value) -&gt; putVal(hash(key), key, value, false, true) -&gt; resize()</code>方法。故HashMap中尤其重要的resize()方法主要实现了两个功能：</key,value></k,v></p>
<ol>
<li>在table数组为null时，对其进行初始化，默认容量为16；</li>
<li>当tables数组非空，但需要调整HashMap的容量时，将hash表容量翻倍。</li>
</ol>
<p>jdk1.8中的resize：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//resize()方法作用有两种：1.初始化hash表的容量，为16； 2.将hash表容量翻倍</span></div><div class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">        Node&lt;K,V&gt;[] oldTab = table;  <span class="comment">//旧hash表</span></div><div class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//旧hash表容量</span></div><div class="line">        <span class="keyword">int</span> oldThr = threshold; <span class="comment">//旧hash表阈值</span></div><div class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;  <span class="comment">//新hash表容量与扩容临界值</span></div><div class="line">        <span class="comment">//2.旧hash表非空，则表容量翻倍</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; </div><div class="line">            <span class="comment">//如果当前的hash表长度已经达到最大值，则不在进行调整</span></div><div class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">                threshold = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">return</span> oldTab;</div><div class="line">            &#125;  <span class="comment">//更新新hash表容量：翻倍</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">                <span class="comment">//更新扩容临界值</span></div><div class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">            newCap = oldThr; </div><div class="line">        <span class="comment">//1. 初始化hash表容量，设为默认值16，并且计算临界值。</span></div><div class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置下次扩容的临界值</span></div><div class="line">        threshold = newThr;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        <span class="comment">//创建一个初始容量为新hash表长度的newTab数组</span></div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">        table = newTab;</div><div class="line">        <span class="comment">//如果旧hash表非空，则按序将旧hash表中的元素重定向到新hash表</span></div><div class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">                Node&lt;K,V&gt; e;  <span class="comment">//e按序指向oldTab数组中的元素，即每个链表中的头结点</span></div><div class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                    oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">//如果链表只有一个头节点</span></div><div class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                    <span class="comment">// 如果节点是红黑树</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                    <span class="comment">//对链表进行秩序维护：因为我们使用的是两倍扩容的方法，所以每个桶里面的元素必须要么待在原来的</span></div><div class="line">                    <span class="comment">//索引所对应的位置，要么在新的桶中位置偏移两倍</span></div><div class="line">                    <span class="keyword">else</span> &#123; </div><div class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                        Node&lt;K,V&gt; next;</div><div class="line">                        <span class="keyword">do</span> &#123;</div><div class="line">                            next = e.next;</div><div class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                    loHead = e;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    loTail.next = e;</div><div class="line">                                loTail = e;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                    hiHead = e;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    hiTail.next = e;</div><div class="line">                                hiTail = e;</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                            loTail.next = <span class="keyword">null</span>;</div><div class="line">                            newTab[j] = loHead;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                            hiTail.next = <span class="keyword">null</span>;</div><div class="line">                            newTab[j + oldCap] = hiHead;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newTab;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>扩容是使用2次幂的扩展(指长度扩为原来2倍)，所以，<br><strong>经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</strong>。</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="image"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt="image"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="image"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>HashMap提供了get(Object key)、containsKey(Object key)、containsValue(Object value)这些查找键值对的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回指定key所映射的value；如果对于该键来说，此映射不包含任何映射关系，则返回 null</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">//key的哈希值为数组下标</span></div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">//检查第一个节点</span></div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> first; </div><div class="line">            <span class="comment">//如果第一个节点不对，则向后检查</span></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果此映射包含对于指定键的映射关系，则返回 true。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果此映射将一个或多个键映射到指定值，则返回 true。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; V v;</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//外层循环搜索数组</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</div><div class="line">                <span class="comment">//内层循环搜索链表</span></div><div class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</div><div class="line">                        (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="清空与删除"><a href="#清空与删除" class="headerlink" title="清空与删除"></a>清空与删除</h4><p>HashMap提供了remove(Object key)删除键值对、clear()清除所有键值对的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从此映射中移除指定键的映射关系（如果存在）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">            <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 用于实现 Map.remove()方法和其他相关的方法</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> hash 键的hash值</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</div><div class="line">        <span class="comment">//table数组非空，键的hash值所指向的数组中的元素非空</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;  <span class="comment">//node指向最终的结果结点，e为链表中的遍历指针</span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;   <span class="comment">//检查第一个节点，如果匹配成功</span></div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                node = p;</div><div class="line">            <span class="comment">//如果第一个节点匹配不成功，则向后遍历链表查找</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                            ((k = e.key) == key ||</div><div class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                            node = e;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        p = e;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)  <span class="comment">//删除node结点</span></div><div class="line">                    tab[index] = node.next;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    p.next = node.next;</div><div class="line">                ++modCount;</div><div class="line">                --size;</div><div class="line">                afterNodeRemoval(node);</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//从此映射中移除所有映射关系</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">            size = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</div><div class="line">                tab[i] = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Java 8 中HashMap是数组+链表+红黑树；</li>
<li>哈希桶数组table的长度length大小必须为2的n次方，也就是我想要创建一个长度为19的HashMap，那么它需要创建的大小为32；HashMap 的 bucket 数组大小一定是2的幂，如果 new 的时候指定了容量且不是2的幂，实际容量会是最接近(大于)指定容量的2的幂，比如 new HashMap&lt;&gt;(19)，比19大且最接近的2的幂是32，实际容量就是32。</li>
<li>没有特殊要求，负载因子使用默认值0.75，并且它可以大于1；</li>
<li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap，HashTable的并发性不如ConcurrentHashMap；</li>
<li>扩容特别消耗性能，初始化的时候，尽量控制好HashMap的大小，避免频繁扩容；</li>
<li>HashMap 在 new 后并不会立即分配哈希桶数组，而是第一次 put 时初始化，类似 ArrayList 在第一次 add 时分配空间。</li>
<li>HashMap 在 put 的元素数量大于 <code>Capacity * LoadFactor</code>（默认<code>16 * 0.75</code>） 之后会进行扩容。</li>
<li>Java 8在哈希碰撞的链表长度达到TREEIFY_THRESHOLD（默认8)后，会把该链表转变成树结构，提高了性能。</li>
<li>Java 8在 resize() 的时候，通过巧妙的设计，减少了 rehash 的性能消耗。</li>
</ol>
<p><strong>参考文章</strong></p>
<p><a rel="external nofollow" target="_blank" href="http://blog.csdn.net/qq_27093465/article/details/52207135">Java 8系列之重新认识HashMap</a><br><a rel="external nofollow" target="_blank" href="http://www.cnblogs.com/CherishFX/p/4739712.html">jdk1.8.0_45源码解读——HashMap的实现</a><br><a rel="external nofollow" target="_blank" href="https://www.cnblogs.com/rogerluo1986/p/5851300.html">HashMap数据结构</a><br><a rel="external nofollow" target="_blank" href="http://blog.csdn.net/u011411283/article/details/48024999">HashMap的性能提升从之链表到二叉树</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap-文档&quot;&gt;&lt;a href=&quot;#HashMap-文档&quot; class=&quot;headerlink&quot; title=&quot;HashMap 文档&quot;&gt;&lt;/a&gt;HashMap 文档&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　HashMap是基于哈希表的Map接口实现的,此实现提供所有可选的映射操作。存储的是&lt;code&gt;&amp;lt;key，value&amp;gt;&lt;/code&gt;对的映射，允许多个null值和一个null键。但此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&lt;br&gt; 　除了HashMap是非同步以及允许使用null外，HashMap 类与 Hashtable大致相同。&lt;br&gt;　 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。&lt;/p&gt;
&lt;p&gt;　　HashMap 的实例有两个参数影响其性能：&lt;code&gt;初始容量&lt;/code&gt; 和&lt;code&gt;加载因子&lt;/code&gt;。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。&lt;strong&gt;加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。&lt;/strong&gt;     &lt;/p&gt;
&lt;p&gt;　　通常，默认&lt;code&gt;加载因子&lt;/code&gt; (0.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。&lt;strong&gt;在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。&lt;/strong&gt;&lt;br&gt;　　注意，此实现&lt;code&gt;不是同步&lt;/code&gt;的。 如果多个线程同时访问一个HashMap实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。这通常是通过同步那些用来封装列表的 对象来实现的。但如果没有这样的对象存在，则应该使用{@link Collections#synchronizedMap Collections.synchronizedMap}来进行“包装”，该方法最好是在创建时完成，为了避免对映射进行意外的非同步操作。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Map m = Collections.synchronizedMap(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap(...));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由所有此类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不会在将来不确定的时间发生任意不确定行为的风险。&lt;/p&gt;
&lt;p&gt;注意，迭代器的&lt;code&gt;快速失败&lt;/code&gt;行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt;。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>解决Hash碰撞冲突方法总结</title>
    <link href="http://blog.wuwii.com/hash-crash.html"/>
    <id>http://blog.wuwii.com/hash-crash.html</id>
    <published>2017-11-15T13:08:03.000Z</published>
    <updated>2017-11-16T01:13:47.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hash碰撞冲突"><a href="#Hash碰撞冲突" class="headerlink" title="Hash碰撞冲突"></a>Hash碰撞冲突</h3><p>我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突。如下将介绍如何处理冲突，当然其前提是一致性hash。</p>
<a id="more"></a>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>开放地执法有一个公式:<code>Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)</code><br>其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。<br>如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。<br>如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
<h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h4><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。<br>比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止</p>
<h4 id="链地址法（拉链法）"><a href="#链地址法（拉链法）" class="headerlink" title="链地址法（拉链法）"></a>链地址法（拉链法）</h4><p>将所有关键字为同义词的记录存储在同一<code>线性链表</code>中。如下：</p>
<p><img src="http://img.blog.csdn.net/20160918154444663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<h4 id="建立一个公共溢出区"><a href="#建立一个公共溢出区" class="headerlink" title="建立一个公共溢出区"></a>建立一个公共溢出区</h4><p>假设哈希函数的值域为<code>[0,m-1]</code>,则设向量<code>HashTable[0..m-1]</code>为基本表，另外设立存储空间向量<code>OverTable[0..v]</code>用以存储发生冲突的记录。</p>
<h4 id="拉链法的优缺点"><a href="#拉链法的优缺点" class="headerlink" title="拉链法的优缺点"></a>拉链法的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</li>
<li>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</li>
<li>开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</li>
<li>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p>
<p><strong>文章转载 <a rel="external nofollow" target="_blank" href="http://blog.csdn.net/zeb_perfect/article/details/52574915">解决Hash碰撞冲突方法总结</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hash碰撞冲突&quot;&gt;&lt;a href=&quot;#Hash碰撞冲突&quot; class=&quot;headerlink&quot; title=&quot;Hash碰撞冲突&quot;&gt;&lt;/a&gt;Hash碰撞冲突&lt;/h3&gt;&lt;p&gt;我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突。如下将介绍如何处理冲突，当然其前提是一致性hash。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哈希算法" scheme="http://blog.wuwii.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>理解一致性哈希算法(consistent hashing)</title>
    <link href="http://blog.wuwii.com/consistent-hashing.html"/>
    <id>http://blog.wuwii.com/consistent-hashing.html</id>
    <published>2017-11-15T06:14:03.000Z</published>
    <updated>2017-11-15T06:14:33.835Z</updated>
    
    <content type="html"><![CDATA[<p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。<br>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：  </p>
<a id="more"></a>
<ol>
<li><code>平衡性(Balance)</code>：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>
<li><code>单调性(Monotonicity)</code>：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </li>
<li><code>分散性(Spread)</code>：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </li>
<li><code>负载(Load)</code>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。<h3 id="分布式集群中，对机器的添加删除"><a href="#分布式集群中，对机器的添加删除" class="headerlink" title="分布式集群中，对机器的添加删除"></a>分布式集群中，对机器的添加删除</h3>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的：</li>
</ol>
<h4 id="环形Hash空间"><a href="#环形Hash空间" class="headerlink" title="环形Hash空间"></a>环形Hash空间</h4><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图：</p>
<p><img src="http://img.blog.csdn.net/20140411000507734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<h4 id="把数据通过一定的hash算法处理后映射到环上"><a href="#把数据通过一定的hash算法处理后映射到环上" class="headerlink" title="把数据通过一定的hash算法处理后映射到环上"></a>把数据通过一定的hash算法处理后映射到环上</h4><p>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Hash(object1) = key1；</div><div class="line">Hash(object2) = key2；</div><div class="line">Hash(object3) = key3；</div><div class="line">Hash(object4) = key4；</div></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20140411000620656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<h4 id="将机器通过hash算法映射到环上"><a href="#将机器通过hash算法映射到环上" class="headerlink" title="将机器通过hash算法映射到环上"></a>将机器通过hash算法映射到环上</h4><p>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Hash(NODE1) = KEY1;</div><div class="line">Hash(NODE2) = KEY2;</div><div class="line">Hash(NODE3) = KEY3;</div></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20140411000853609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p>
<h4 id="机器的删除与添加"><a href="#机器的删除与添加" class="headerlink" title="机器的删除与添加"></a>机器的删除与添加</h4><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p>
<h5 id="节点（机器）的删除"><a href="#节点（机器）的删除" class="headerlink" title="节点（机器）的删除"></a>节点（机器）的删除</h5><p>以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：</p>
<p><img src="http://img.blog.csdn.net/20140411001033656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<h5 id="节点（机器）的添加"><a href="#节点（机器）的添加" class="headerlink" title="节点（机器）的添加"></a>节点（机器）的添加</h5><p> 如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：</p>
<p> <img src="http://img.blog.csdn.net/20140411001211062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p>  通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p>
<h4 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h4><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。</p>
<blockquote>
<p>——“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。</p>
</blockquote>
<p>以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p>
<p><img src="http://img.blog.csdn.net/20140411001433375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p>根据上图可知对象的映射关系：<code>object1-&gt;NODE1-1</code>，<code>object2-&gt;NODE1-2</code>，<code>object3-&gt;NODE3-2</code>，<code>object4-&gt;NODE3-1</code>。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：</p>
<p><img src="http://img.blog.csdn.net/20140411001540656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p><code>虚拟节点</code>的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：<br><code>Hash(“192.168.1.100”)</code>;<br>引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：<br><code>Hash(“192.168.1.100#1”); // NODE1-1</code><br><code>Hash(“192.168.1.100#2”); // NODE1-2</code></p>
<p><strong>文章转载 <a rel="external nofollow" target="_blank" href="http://blog.csdn.net/cywosp/article/details/23397179">每天进步一点点——五分钟理解一致性哈希算法(consistent hashing)</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。&lt;br&gt;一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：  &lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://blog.wuwii.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希算法" scheme="http://blog.wuwii.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Optional类的分析与使用</title>
    <link href="http://blog.wuwii.com/java-optional.html"/>
    <id>http://blog.wuwii.com/java-optional.html</id>
    <published>2017-11-12T13:08:03.000Z</published>
    <updated>2017-11-13T02:09:45.476Z</updated>
    
    <content type="html"><![CDATA[<p><code>Optional</code> 类 是<code>jdk 1.8</code>后新添加的特性，阿里巴巴的代码规范也明确说明了使用 Optional 来防止NPE。</p>
<blockquote>
<p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。<br>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<br>Optional 类的引入很好的解决空指针异常。</p>
</blockquote>
<a id="more"></a>
<p>它拥有的方法：<img src="http://ov62kaxkk.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171112172632.png" alt="image"></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @since 1.8</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Common instance for &#123;<span class="doctag">@code</span> empty()&#125;.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * If non-null, the value; if null, indicates no value is present</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>value 属性就是存储数据的地方。如果为null，表示没有值的存在，取值的时候如果没有默认值，会抛出空指针。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>它拥有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Constructs an empty instance.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@implNote</span> Generally only one empty instance, &#123;<span class="doctag">@link</span> Optional#EMPTY&#125;,</span></div><div class="line"><span class="comment"> * should exist per VM.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Constructs an instance with the value present.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> value the non-null value to be present</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if value is null</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = Objects.requireNonNull(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一个构造一个空的Optional；</li>
<li>第二个构造一个值为value的Optional，值为null会抛出NPE；</li>
</ul>
<h4 id="of"><a href="#of" class="headerlink" title="of"></a>of</h4><blockquote>
<p>为非null的值创建一个Optional。</p>
</blockquote>
<p>of方法通过工厂方法创建Optional类。需要注意的是，创建对象时传入的参数不能为null。如果传入参数为null，则抛出NullPointerException。<br>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出它最后调用的是第二个有参的构造函数，所以它传入的参数也为null会抛出空指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; spring = Optional.of(<span class="string">"SPRING"</span>);</div><div class="line">Optional&lt;String&gt; emptyStr = Optional.of(<span class="string">""</span>);</div><div class="line">Optional&lt;String&gt; nullValue = Optional.of(<span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>最后个创建Optional实例会抛出空指针异常。</p>
<h4 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Optional&#125; describing the specified value, if non-null,</span></div><div class="line"><span class="comment"> * otherwise returns an empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the class of the value</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> value the possibly-null value to describe</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Optional&#125; with a present value if the specified value</span></div><div class="line"><span class="comment"> * is non-null, otherwise an empty &#123;<span class="doctag">@code</span> Optional&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。<br>相比较of 方法，能够接受 null 参数。</p>
<h4 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h4><p>判断值是否存在。值不为null，返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value != <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>取出存在Optional 中的值，为Null 抛出<code>NoSuchElementException</code>异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"No value present"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * If a value is present, invoke the specified consumer with the value,</span></div><div class="line"><span class="comment"> * otherwise do nothing.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> consumer block to be executed if a value is present</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if value is present and &#123;<span class="doctag">@code</span> consumer&#125; is</span></div><div class="line"><span class="comment"> * null</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</div><div class="line">        consumer.accept(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对传入的值使用<code>Consumer</code>接口的accept方法进行处理，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Performs this operation on the given argument.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> t the input argument</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div></pre></td></tr></table></figure></p>
<p>实际上就是可以使用函数式编程了，使用lambda表达式方法了，前提是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.ifPresent(a -&gt; System.out.println(a.indexOf(&quot;I&quot;)));</div></pre></td></tr></table></figure></p>
<p>结果为 <code>3</code>。</p>
<h4 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h4><p>如果有值则将其返回，否则返回指定的其它值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"有值的Optional: %s，没值的Optional：%s%n"</span>,</div><div class="line">                spring.orElse(<span class="string">"summer"</span>), nullValue.orElse(<span class="string">"summer"</span>));</div></pre></td></tr></table></figure>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">有值的Optional: SPRING，没值的Optional：summer</div></pre></td></tr></table></figure></p>
<h4 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h4><p>orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值，由于参数是接口形式，直接使用lambda表达式，更方便。<br>能接收函数式返回处理的数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"有值的Optional: %s，没值的Optional：%s%n"</span>,</div><div class="line">                spring.orElseGet(() -&gt; <span class="string">"summer"</span>),</div><div class="line">                nullValue.orElseGet(() -&gt; <span class="string">"summer"</span>));</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">有值的Optional: SPRING，没值的Optional：summer</div></pre></td></tr></table></figure></p>
<h4 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h4><p>如果有值则将其返回，否则抛出supplier接口创建的异常。<br>在上面的 orElseGet 方法中，传入的是Supplier接口的实现，在orElseThrow中传入一个Throwable ，如果值不存在来抛出传入的指定类型异常，源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">        <span class="comment">//orElseThrow</span></div><div class="line">        System.out.printf(<span class="string">"orElseThrow有值的Optional: %s，没值的Optional：%s%n"</span>,</div><div class="line">                spring.orElseThrow(OptionalThrowable::<span class="keyword">new</span>),</div><div class="line">                nullValue.orElseThrow(OptionalThrowable::<span class="keyword">new</span>));</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 自定义的Optional异常类</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptionalThrowable</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OptionalThrowable</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OptionalThrowable</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//return super.getMessage();</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"这个Optional 是空值"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果符合预期错误抛出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">有值的Optional: SPRING，没值的Optional：summer</div><div class="line">Exception in thread &quot;main&quot; com.wuwii.utils.OptionalThrowable: 这个Optional 是空值</div><div class="line">	at java.util.Optional.orElseThrow(Optional.java:290)</div><div class="line">	at com.wuwii.utils.OptionalTest.main(OptionalTest.java:28)</div></pre></td></tr></table></figure></p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><blockquote>
<p>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。</p>
</blockquote>
<p>map就是stream中的方法一样的，是用来操作的，用来对Optional实例的值执行一系列操作，所以我们可以灵活的使用Function包的方法和lamdba表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//map</span></div><div class="line">        Optional&lt;String&gt; castedOptional = spring.map(String::toLowerCase);</div><div class="line">        System.out.printf(<span class="string">"转换过后的值：%s%n"</span>, castedOptional.orElseGet(<span class="keyword">null</span>));</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">转换过后的值：spring</div></pre></td></tr></table></figure></p>
<p>可以看出转换成小写的了。</p>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><blockquote>
<p>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//flatMap</span></div><div class="line">        Optional&lt;String&gt; upperOptional = castedOptional.flatMap(a -&gt; Optional.of(a.toUpperCase()));</div><div class="line">        System.out.printf(<span class="string">"将上面小写的castedOptional 转换成大写：%s%n"</span>, upperOptional.orElseGet(<span class="keyword">null</span>));</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">将上面小写的castedOptional 转换成大写：SPRING</div></pre></td></tr></table></figure></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><blockquote>
<p>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。</p>
</blockquote>
<p>过滤，对于filter函数我们应该传入实现了Predicate接口的lambda表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/filter</div><div class="line">        <span class="comment">//过滤掉长度不大于10的，SPRING长度小于10，故此被过滤了</span></div><div class="line">        Optional&lt;String&gt; filterOptional = upperOptional.filter(a -&gt; a.length() &gt; <span class="number">10</span>);</div><div class="line">        System.out.printf(<span class="string">"过滤掉长度不大于10的 ：%s%n"</span>, filterOptional.orElse(<span class="string">"Default value"</span>));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">过滤掉长度不大于10的结果 ：Default value</div></pre></td></tr></table></figure></p>
<h3 id="学习的所有代码"><a href="#学习的所有代码" class="headerlink" title="学习的所有代码"></a>学习的所有代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.wuwii.utils;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Optional;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 学习Optional</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>: Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> : 2017/11/12 20:40</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//of</span></div><div class="line">        Optional&lt;String&gt; spring = Optional.of(<span class="string">"SPRING"</span>);</div><div class="line">        Optional&lt;String&gt; emptyStr = Optional.of(<span class="string">""</span>);</div><div class="line">		<span class="comment">//会抛出异常NPE</span></div><div class="line">        <span class="comment">//Optional&lt;String&gt; nullValue1 = Optional.of(null); </span></div><div class="line">		<span class="comment">//不会抛异常，做了判断</span></div><div class="line">        Optional&lt;String&gt; nullValue = Optional.ofNullable(<span class="keyword">null</span>);</div><div class="line">		</div><div class="line">        <span class="comment">//ifPresent</span></div><div class="line">        spring.ifPresent(a -&gt; System.out.println(a.indexOf(<span class="string">"I"</span>)));</div><div class="line">		</div><div class="line">        <span class="comment">//orElse</span></div><div class="line">        System.out.printf(<span class="string">"orElse有值的Optional: %s，没值的Optional：%s%n"</span>,</div><div class="line">                spring.orElse(<span class="string">"summer"</span>), nullValue.orElse(<span class="string">"summer"</span>));</div><div class="line">				</div><div class="line">        <span class="comment">//orElseGet</span></div><div class="line">        System.out.printf(<span class="string">"orElseGet有值的Optional: %s，没值的Optional：%s%n"</span>,</div><div class="line">                spring.orElseGet(() -&gt; <span class="string">"summer"</span>),</div><div class="line">                nullValue.orElseGet(() -&gt; <span class="string">"summer"</span>));</div><div class="line">				</div><div class="line">        <span class="comment">//orElseThrow</span></div><div class="line">		<span class="comment">// 这段代码会抛出异常，为了下面能运行，先注释。</span></div><div class="line">        <span class="comment">/*try &#123;</span></div><div class="line"><span class="comment">            System.out.printf("orElseThrow有值的Optional: %s，没值的Optional：%s%n",</span></div><div class="line"><span class="comment">                    spring.orElseThrow(OptionalThrowable::new),</span></div><div class="line"><span class="comment">                    nullValue.orElseThrow(OptionalThrowable::new));</span></div><div class="line"><span class="comment">        &#125; catch (OptionalThrowable optionalThrowable) &#123;</span></div><div class="line"><span class="comment">            optionalThrowable.printStackTrace();</span></div><div class="line"><span class="comment">        &#125;*/</span></div><div class="line"></div><div class="line">        <span class="comment">//map</span></div><div class="line">        Optional&lt;String&gt; castedOptional = spring.map(String::toLowerCase);</div><div class="line">        System.out.printf(<span class="string">"转换成小写的值：%s%n"</span>, castedOptional.orElseGet(<span class="keyword">null</span>));</div><div class="line"></div><div class="line">        <span class="comment">//flatMap</span></div><div class="line">        Optional&lt;String&gt; upperOptional = castedOptional.flatMap(a -&gt; Optional.of(a.toUpperCase()));</div><div class="line">        System.out.printf(<span class="string">"将上面小写的castedOptional 转换成大写：%s%n"</span>, upperOptional.orElseGet(<span class="keyword">null</span>));</div><div class="line"></div><div class="line">        <span class="comment">//filter</span></div><div class="line">        <span class="comment">//过滤掉长度不大于10的，SPRING长度小于10，故此被过滤了</span></div><div class="line">        Optional&lt;String&gt; filterOptional = upperOptional.filter(a -&gt; a.length() &gt; <span class="number">10</span>);</div><div class="line">        System.out.printf(<span class="string">"过滤掉长度不大于10的结果 ：%s%n"</span>, filterOptional.orElse(<span class="string">"Default value"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 自定义的Optional异常类</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptionalThrowable</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OptionalThrowable</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OptionalThrowable</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//return super.getMessage();</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"这个Optional 是空值"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; 类 是&lt;code&gt;jdk 1.8&lt;/code&gt;后新添加的特性，阿里巴巴的代码规范也明确说明了使用 Optional 来防止NPE。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。&lt;br&gt;Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。&lt;br&gt;Optional 类的引入很好的解决空指针异常。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>歌词-《清白之年》</title>
    <link href="http://blog.wuwii.com/innocence-year.html"/>
    <id>http://blog.wuwii.com/innocence-year.html</id>
    <published>2017-11-12T07:08:03.000Z</published>
    <updated>2017-11-13T02:09:45.468Z</updated>
    
    <content type="html"><![CDATA[<p>热爱美丽又遗憾的世界，愿你出走半生，归来仍是少年。<br>一直有人，再让我幻想。。</p>
<p><img src="https://i.loli.net/2017/11/12/5a07fbf87973b.jpg" alt="img"></p>
<a id="more"></a>
<blockquote class="blockquote-center"><h3 id="清白之年"><a href="#清白之年" class="headerlink" title="清白之年"></a>清白之年</h3><p>词 : 朴树 </p>
<hr>
<p>故事开始以前 </p>
<p>最初的那些春天<br>阳光洒在杨树上 风吹来 闪银光 </p>
<p>街道平静而温暖<br>钟走得好慢 </p>
<p>那是我还不识人生之味的年代 </p>
<p>我情窦还不开 </p>
<p>你的衬衣如雪 </p>
<p>盼着杨树叶落下 眼睛不眨 </p>
<p>心里像有一些话<br>我们先不讲 </p>
<p>等待着那将要盛装出场的未来 </p>
<p>人随风飘荡 </p>
<p>天各自一方 </p>
<p>在风尘中遗忘的清白脸庞 </p>
<p>此生多勉强 </p>
<p>此身越重洋 </p>
<p>轻描时光漫长低唱语焉不详 </p>
<p>数不清的流年 </p>
<p>似是而非的脸<br>把你的故事对我讲<br>就让我笑出泪光<br>是不是生活太艰难<br>还是活色生香 </p>
<p>我们都遍体鳞伤 </p>
<p>也慢慢坏了心肠 </p>
<p>你得到你想要的吗<br>换来的是铁石心肠 </p>
<p>可曾还有什么人<br>再让你幻想 </p>
<p>大风吹来了<br>我们随风飘荡 </p>
<p>在风尘中遗忘的清白脸庞 </p>
<p>此生多寒凉 </p>
<p>此身越重洋 </p>
<p>轻描时光漫长低唱语焉不详 </p>
<p>大风吹来了<br>我们随风飘荡 </p>
<p>在风尘中熄灭的清澈目光 </p>
<p>我想回头望 </p>
<p>把故事从头讲<br>时光迟暮不返人生已不再来</p>
</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;热爱美丽又遗憾的世界，愿你出走半生，归来仍是少年。&lt;br&gt;一直有人，再让我幻想。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/12/5a07fbf87973b.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="那些很美的句子" scheme="http://blog.wuwii.com/categories/%E9%82%A3%E4%BA%9B%E5%BE%88%E7%BE%8E%E7%9A%84%E5%8F%A5%E5%AD%90/"/>
    
    
      <category term="歌词" scheme="http://blog.wuwii.com/tags/%E6%AD%8C%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>20171111</title>
    <link href="http://blog.wuwii.com/20171111.html"/>
    <id>http://blog.wuwii.com/20171111.html</id>
    <published>2017-11-11T13:11:03.000Z</published>
    <updated>2017-11-13T02:09:45.318Z</updated>
    
    <content type="html"><![CDATA[<p>想到凌晨，双十一，还是忍不住买买买，很舒心，最好的就是这个时候能给父母多买点东西，平时说缺什么他们都不让，这个时候多买点，还买了一个电饭煲，还不错，苏泊尔的。</p>
<p>半夜久久不能入睡，我想我是刚刚聊天失眠了，等消息，还不如看个电影，又翻出以前很爱看的《猫的感恩》，深夜3点才能睡着。。</p>
<p>早上一起来快9点啦，，经理还发消息问什么时候才能过来，尬。当然迟到了，他们已经在开会了，。</p>
<p>一上午就没心思听进去了，犹豫了半天才评论了一个说说，我这个人就是这样的，一点东西也算是个惊喜吧。</p>
<p>下午一个人去磨山骑车玩玩，东湖的风景还是很好的。为什么出去还这么累啊，我看是今天黄道吉日不好吧，双十一，单身狗不宜出门。</p>
<p>晚上回来随便写点，洗洗睡吧，生活大抵就是这么无聊咯，我的青春，呼喊了也没回应，只能自己创造了。加油。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想到凌晨，双十一，还是忍不住买买买，很舒心，最好的就是这个时候能给父母多买点东西，平时说缺什么他们都不让，这个时候多买点，还买了一个电饭煲，还不错，苏泊尔的。&lt;/p&gt;
&lt;p&gt;半夜久久不能入睡，我想我是刚刚聊天失眠了，等消息，还不如看个电影，又翻出以前很爱看的《猫的感恩》，深
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>成长</title>
    <link href="http://blog.wuwii.com/grow-up.html"/>
    <id>http://blog.wuwii.com/grow-up.html</id>
    <published>2017-11-10T14:08:03.000Z</published>
    <updated>2017-11-13T02:09:45.461Z</updated>
    
    <content type="html"><![CDATA[<p>多想多说话，也只有我知道，是因为我害怕，我怕别人听出来，过得不好，我怕问我过得怎么样的时候，可能会你难过，我怕撑不住告诉了别人。</p>
<p>我知道，一个男人应该更坚强一点，所以我从来不跟别人说那些丧气，而又愤怒的话，从来不跟别人说我过得怎么样，谁问我，都能轻描淡写，一笔带过。挺好的，真的什么都挺好的。</p>
<p>现在虽然离梦想还有一大截，薪水也很普通，但也还能存下一笔钱，感觉有了能撑起一个家的责任和感觉了，从心底上就有了一份骄傲。</p>
<p>室友的关心，也会让人心里暖暖的，也还有人能说话，生活有时候不如意，但是为之奋斗的梦想还没有扔下，还知道为什么要这么做，想要的是什么，虽然现在有时候真的很难熬，但是我知道的，总会好的，不会太远；曾经遇到的事，吃过的苦，总有一天，会赶在父母老去之前，给他们更好的生活；总有一天也会遇到一个人，那一天我真的有能力能给她安稳，照顾她一辈子了。</p>
<p>有时候憧憬下未来，想想现在，其实也没什么大不了的，人生充满荆棘，等待去跨过，才能有理想，才能成长；其实也没什么好惧怕的，我还有梦，有家，有爱的能力就够了；其实也不难熬，只是有些事情只能自己消化，不再赶和任何人一起罢了。</p>
<p>其实真的没什么大不了的，人总是要学会长大的，一个人撑起一个家，一个人抵过千军万马。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多想多说话，也只有我知道，是因为我害怕，我怕别人听出来，过得不好，我怕问我过得怎么样的时候，可能会你难过，我怕撑不住告诉了别人。&lt;/p&gt;
&lt;p&gt;我知道，一个男人应该更坚强一点，所以我从来不跟别人说那些丧气，而又愤怒的话，从来不跟别人说我过得怎么样，谁问我，都能轻描淡写，一笔
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>JPA多表查询的解决办法</title>
    <link href="http://blog.wuwii.com/jpa-query-muti.html"/>
    <id>http://blog.wuwii.com/jpa-query-muti.html</id>
    <published>2017-11-09T09:50:03.000Z</published>
    <updated>2017-11-09T09:49:05.187Z</updated>
    
    <content type="html"><![CDATA[<p>实际业务中，多表关联查询应用实例很多，怎么使用JPA进行多表查询，可以选择不同的方法优化。<br>记下在JPA中多表查询的有效使用方法。<br><a id="more"></a></p>
<h3 id="使用关系映射"><a href="#使用关系映射" class="headerlink" title="使用关系映射"></a>使用关系映射</h3><p>就是使用一对多，多对一，一对一这种关系进行关联映射，</p>
<p>一个一对多迭代Tree的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> javax.persistence.*;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据组织取得实时轨迹Tree的业务类</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/9 15:21&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="meta">@Table</span>(name = <span class="string">"\"DEV_ORGANIZE\""</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizeMappedEntity</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</div><div class="line">    <span class="comment">// 名称，为了前面取出数据的key一致性，换个名称。</span></div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"\"NAME\""</span>)</div><div class="line">    <span class="keyword">private</span> String no;</div><div class="line">    <span class="comment">// 父组织外键</span></div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"\"PARENTID\""</span>)</div><div class="line">    <span class="keyword">private</span> String parentid;</div><div class="line"></div><div class="line">    <span class="meta">@OneToMany</span>(targetEntity = OrganizeMappedEntity.class,</div><div class="line">            mappedBy = <span class="string">"parentid"</span>, cascade = &#123;CascadeType.ALL&#125;, fetch = FetchType.EAGER)</div><div class="line">    <span class="keyword">private</span> List children;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> no;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(String no)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.no = no;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParentid</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> parentid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParentid</span><span class="params">(String parentid)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parentid = parentid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> children;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(List children)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.children = children;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>平常使用这种方法最多了，因为方便，少写代码，但是平时不一定需要查询所有，而且在数据比较多的情况下，开销比较大，就得使用下面第二种方法。</p>
<h3 id="使用JPQL多表查询"><a href="#使用JPQL多表查询" class="headerlink" title="使用JPQL多表查询"></a>使用JPQL多表查询</h3><p><code>JPQL</code>全称<code>Java Presistence Query Language</code>，Java持久化查询语言。和Hibernate的HQL语句差不多。</p>
<p>现在测试下，从A表和B表各取出一个字段吧。<br>创建一个业务实体DTO：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//学习学习</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * </span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line">        <span class="comment">//A表字段No</span></div><div class="line">	<span class="keyword">private</span> String no;</div><div class="line">	<span class="comment">//B表字段tel</span></div><div class="line">	<span class="keyword">private</span> String tel;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Long num;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="title">TestEntity</span><span class="params">(Long num)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.num = num;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getNum</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(Long num)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.num = num;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//通过构造函数注入值</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestEntity</span> <span class="params">(String no, String tel)</span> </span>&#123;</div><div class="line">    	<span class="keyword">this</span>.no = no;</div><div class="line">    	<span class="keyword">this</span>.tel = tel;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getSerialversionuid</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> serialVersionUID;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getNo</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> no;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(String no)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.no = no;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTel</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> tel;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTel</span><span class="params">(String tel)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.tel = tel;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//重写写，</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"TestEntity&#123;"</span> +</div><div class="line">				<span class="string">"no='"</span> + no + <span class="string">'\''</span> +</div><div class="line">				<span class="string">", tel='"</span> + tel + <span class="string">'\''</span> +</div><div class="line">				<span class="string">", num="</span> + num +</div><div class="line">				<span class="string">'&#125;'</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样可以使用业务实体类的构造函数就行绑定数据了。</p>
<p>Dao层查询数据库的JPQL语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> com.devframe.database.BasePagingAndSortingRepository;</div><div class="line"><span class="keyword">import</span> com.devframe.entity.DeviceEntity;</div><div class="line"><span class="keyword">import</span> com.devframe.entity.TestEntity;</div><div class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="meta">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeviceDao</span> <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">DeviceEntity</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 只为学习。。。</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> List&lt;TestEntity&gt;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">	<span class="meta">@Query</span>(value = <span class="string">"SELECT new com.devframe.entity.TestEntity(a.no, b.tel) FROM com.devframe.entity.DeviceEntity a, com.devframe.entity.OrganizeEntity b WHERE a.orgid = b.id"</span>)</div><div class="line">	<span class="function">List&lt;TestEntity&gt; <span class="title">gettest</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用join查询出两个表相关联的所有列。</p>
<p>单元测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> com.devframe.dao.DeviceDao;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.annotation.Resource;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/9 17:40&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/applicationContext-base.xml"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceDaoTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="keyword">private</span> DeviceDao dao;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGettest</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(dao.gettest());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数据有点多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TestEntity&#123;no=&apos;N57008&apos;, tel=&apos;null&apos;, num=null&#125;, TestEntity&#123;no=&apos;N33505&apos;, tel=&apos;null&apos;, num=null&#125;, TestEntity&#123;no=&apos;N88001&apos;, tel=&apos;null&apos;, num=null&#125;,省略...</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际业务中，多表关联查询应用实例很多，怎么使用JPA进行多表查询，可以选择不同的方法优化。&lt;br&gt;记下在JPA中多表查询的有效使用方法。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
      <category term="jpa" scheme="http://blog.wuwii.com/tags/jpa/"/>
    
  </entry>
  
  <entry>
    <title>20171107</title>
    <link href="http://blog.wuwii.com/20171107.html"/>
    <id>http://blog.wuwii.com/20171107.html</id>
    <published>2017-11-07T15:12:03.000Z</published>
    <updated>2017-11-08T05:30:37.777Z</updated>
    
    <content type="html"><![CDATA[<p>今天乱的一匹，也没怎么学习，日记也没写，故事也没写。</p>
<p>什么都别想，<br>管这个世界明天会怎样，<br>卸下今天的一切，<br>在艰难的时光里，<br>将人生变得美好而辽阔。</p>
<hr>
<p>最近任务有点杂乱，效率低下。回想起最近，学的东西太杂乱了</p>
<p>回想起最近这么几个月，学的东西太杂乱了，分布式存储，分布式缓存，hadoop，python等等，没一个弄清楚明白的，剩下的时间里，先把python放下，把Java中这么几个重要的东西仔细研究一下，只要掌握一门，以后工作就好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天乱的一匹，也没怎么学习，日记也没写，故事也没写。&lt;/p&gt;
&lt;p&gt;什么都别想，&lt;br&gt;管这个世界明天会怎样，&lt;br&gt;卸下今天的一切，&lt;br&gt;在艰难的时光里，&lt;br&gt;将人生变得美好而辽阔。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最近任务有点杂乱，效率低下。回想起最近，学的东西太杂乱了&lt;/
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>2017年，仅剩60天不到了</title>
    <link href="http://blog.wuwii.com/2017left.html"/>
    <id>http://blog.wuwii.com/2017left.html</id>
    <published>2017-11-06T15:08:03.000Z</published>
    <updated>2017-11-13T02:09:45.358Z</updated>
    
    <content type="html"><![CDATA[<p>猛然发现，2017，转眼就要过完了，我这个人从来不喜欢记什么节日，自己的生日有时候都要老爸老妈操心的，我也不太喜欢倒计时，最特别的就是高考倒计时吧。当人从出生的那一刻起，就过上了讨厌的倒计时的生活。</p>
<a id="more"></a>
<p>感觉今年过得很没意思，怎么说了。<br>年初，就去实习公司上班，不为别的只为那个开门红，红包。开始工作的时候，大都是热情满满，感觉怎么样怎么样的好，可是期望满满，后来失望就慢慢多了，感觉工作并没有那么顺心，领导开始只注意项目了，不关心员工死活了，渐渐的我就是失去的热情。有点颓废。</p>
<p>也是刚好，项目的事情没那么多，可以好好写下论文了，大概三月中旬我就开始着手自己毕业设计，直接想了一个以前准备做的OA系统，其实这个还是挺难的，因为最后做得有点失败，后面说。整整四月份都在做这个项目，中间遇到过很多问题，大多数都解决了（有的敷衍了），也有十多万行代码吧（虽然质量很差），没仔细统计过，就是公司上班没什么事，一天到晚写毕业设计一个月，直到五月初才开始写论文。然后就是毕业设计熬过去。然后就是答辩了，so easy，毕竟全篇都是自己完成的，只不过我是小组最后一个答辩，弄完都快晚上八点了。</p>
<p>六月份到公司重新报道吧，没什么可说的，开始接到一个很坑的项目，直接导致我想离开的原因。</p>
<p>七月份就是做那个苦逼的项目，室友封闭一个月，我一个人生活了一个多月，感觉习惯了孤独。</p>
<p>还有一件事情就是，也是我想直接留在武汉的原因吧，主要还是想那个她吧，可是我当时又不敢见她，聊天也怕没话题，知道她还是单身，我多次尝试去找她，但是她对我很冷吧，所以又没去联系，还是不打破美好吧，后来她有男友，虽然让我消沉一阵子，当然这是后话了。</p>
<p>八月份中旬，经前任经历推荐，来到了新的公司，虽然是做农业的，不是真正的互联网公司，但是在武汉待遇还很好，经理待人也不错，就是很少加班，但是IT行业不学习的话，感觉人就要倒退了，所以呀，每天至少得在公司蹭一个小时的网，来学习学习。部门的员工很和谐，感觉很轻松，让我工作动力十足，相信可以成长很快的。</p>
<p>在新公司已经两个月了，学习了不少，这个博客笔记也是进入到这个公司才开始正式写的，希望能够陪伴着我进步。</p>
<p>最后的梦想就是，当然是快点成为技术大牛，拿高薪。<br>工作方向的话，主Java开发，物联网，互联网，再就是大数据，补算法，python，人工智能。<br>说起以后工作的城市，人生路还长，现在才刚开始，自己努力了，总有个地方能给你安稳的地方。<br>说起工作城市，还不是面向工资，主要是武汉工资确实太低了，但真的很喜欢武汉的这个城市。不知道明年继续待在武汉，有机会税前过万吗？<br>说起以后的希望实现财富自由的期望工资，标准是超一线年薪30万起吧，一线20万吧，才算合格。当然是以目前的背景基础看的，程序猿的工资只会越来越高的，要坚持努力工作，学习，加油，希望三年能完成一个阶段吧。</p>
<p>当然最希望能遇到一个对的人，我有好多故事要跟你讲啊，想去好多地方，虽然害怕自己习惯了孤独，只要是对的人，还是等得起，不是不想去喜欢一个人，害怕自己再也付出不了真心，真的是好犹豫啊，人真是病态的厉害。</p>
<p>今年总结这么快就开始写了，其实没什么，好多牢骚，完全扭曲了人生观，就这样，加油，努力，现在每天只好自己对自己说声晚安了，我相信这种状况不会太久，希望不会太远，真的好累。</p>
<p>有点矫情了。。。</p>
<p>晚安！</p>
<hr>
<p>(continue:</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;猛然发现，2017，转眼就要过完了，我这个人从来不喜欢记什么节日，自己的生日有时候都要老爸老妈操心的，我也不太喜欢倒计时，最特别的就是高考倒计时吧。当人从出生的那一刻起，就过上了讨厌的倒计时的生活。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>做个温柔的人</title>
    <link href="http://blog.wuwii.com/tobe-gentle.html"/>
    <id>http://blog.wuwii.com/tobe-gentle.html</id>
    <published>2017-11-05T13:51:03.000Z</published>
    <updated>2017-11-07T10:34:22.749Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>要有在迷茫沮丧的时期，不对自己下结论的能力；在苦楚绝望的时期，不对世界下结论的操守。你要相信，一切都是暂时的，我们唯一需要做的，就是静静地好给世界看。</p>
</blockquote>
<a id="more"></a>
<p>最近感觉生活过的一团糟，书看不下去，博客也写不下去，我想我是个脾气有点爆的人，感觉生活就是很失望一般。</p>
<p>你是那么会安慰人，非得逞强去安慰别人，是什么让人这样，真是不撞南墙不回头，把南墙装得头破血流，也回不了头，只能往前走。这段时间真想对曾经自己的说声对不起，自己真的是很难过，</p>
<p>你是那么会安慰人，生活就是这样，一边安慰着鄙人，一边悄悄自愈着，自己糟糕，安慰别人却头头是道。</p>
<p>你是那么会安慰人，可能是曾经期望太高，导致现在一点一点的失望，失望到，似乎看到那个结局。继续安慰别人，下去就是忍受孤独吧。</p>
<p>然后不知不觉中，顾虑似乎多了不少，身上的包袱就沉重了许多，有些事情，虽然基本已经跟自己无关，但是还不愿意卸下，会上去悉心照顾下她人的感受，可是安慰完这个世界后，感觉没人会安慰自己了，也没人能够懂得自己现在的感受。</p>
<p>可能你也不懂得如何安慰别人，习惯一个人在外面打拼久了，什么都是自己一个人，没事什么都可以撑得下，已经习惯用坚强来安慰自己。</p>
<p>可能你也不懂得如何安慰别人，还是努力把自己最好的一面留给别人，不要去祈求来的安慰，只会是同情，还不如自己吞下所有的难过。</p>
<p>世界上有种傻子，在最难过的时候，还在想着怎么安慰别人，虽然没有关系，也不用在意。</p>
<p>自己一直不知道，有多少人和我一般笨拙，安慰人的话没说几句就词穷了。</p>
<p>所以现在多了一种安慰方式：沉默。</p>
<p>现在知道了。我确实不会安慰人。</p>
<p>只求往后的日子里，希望自己能想明白事情，再去做吧，这样就不会出现这么多的问题，即辜负了别人，也辜负了自己。  </p>
<p>往后的日子里做个温柔的人，无惧黑暗与严寒，只会把温暖带给世界，然后花点时间温暖自己，变得更加优秀。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;要有在迷茫沮丧的时期，不对自己下结论的能力；在苦楚绝望的时期，不对世界下结论的操守。你要相信，一切都是暂时的，我们唯一需要做的，就是静静地好给世界看。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程中Lock</title>
    <link href="http://blog.wuwii.com/java-lock.html"/>
    <id>http://blog.wuwii.com/java-lock.html</id>
    <published>2017-11-05T06:48:03.000Z</published>
    <updated>2017-11-05T07:22:24.913Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p>
<ol>
<li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li>
<li>线程执行发生异常，此时JVM会让线程自动释放锁。</li>
</ol>
<a id="more"></a>
<p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</p>
<p>　　因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p>
<p>　　再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p>
<p>　　但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p>
<p>　　如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</p>
<p>　　因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p>
<p>　　另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p>
<p>　　总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p>
<ol>
<li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li>
<li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li>
</ol>
<h3 id="java-util-concurrent-locks包下常用的类"><a href="#java-util-concurrent-locks包下常用的类" class="headerlink" title="java.util.concurrent.locks包下常用的类"></a>java.util.concurrent.locks包下常用的类</h3><p>java.util.concurrent.locks包中常用的类和接口。</p>
<h4 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@since</span> <span class="number">1.5</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来逐个讲述Lock接口中每个方法的使用，lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。newCondition()这个方法暂且不在此讲述，会在后面的线程协作一文中讲述。</p>
<p>　　在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？</p>
<h5 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h5><p>　　首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p>
<p>　　由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Lock lock = ...;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//处理任务</span></div><div class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line">     </div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line">    lock.unlock();   <span class="comment">//释放锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h5><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p>
<p>　　tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p>
<p>　　所以，一般情况下通过tryLock来获取锁时是这样使用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Lock lock = ...;</div><div class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</div><div class="line">     <span class="keyword">try</span>&#123;</div><div class="line">         <span class="comment">//处理任务</span></div><div class="line">     &#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line">         </div><div class="line">     &#125;<span class="keyword">finally</span>&#123;</div><div class="line">         lock.unlock();   <span class="comment">//释放锁</span></div><div class="line">     &#125; </div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//如果不能获取锁，则直接做其他事情</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h5><p>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p>
<p>　　由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p>
<p>　　因此lockInterruptibly()一般的使用形式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;  </div><div class="line">     <span class="comment">//.....</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="ReentrantLock类"><a href="#ReentrantLock类" class="headerlink" title="ReentrantLock类"></a>ReentrantLock类</h4><p>ReentrantLock，意思是“可重入锁”。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p>
<h5 id="例子1，lock-的正确使用方法"><a href="#例子1，lock-的正确使用方法" class="headerlink" title="例子1，lock()的正确使用方法:"></a>例子1，lock()的正确使用方法:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.insert(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.insert(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</div><div class="line">                arrayList.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果是什么:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread-0得到了锁</div><div class="line">Thread-1得到了锁</div><div class="line">Thread-0释放了锁</div><div class="line">Thread-1释放了锁</div></pre></td></tr></table></figure></p>
<p>也许有朋友会问，怎么会输出这个结果？第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么理所当然每个线程执行到lock.lock()处获取的是不同的锁，所以就不会发生冲突。</p>
<p>　　知道了原因改起来就比较容易了，只需要将lock声明为类的属性即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.insert(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.insert(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</div><div class="line">                arrayList.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="例子2，tryLock-的使用方法"><a href="#例子2，tryLock-的使用方法" class="headerlink" title="例子2，tryLock()的使用方法"></a>例子2，tryLock()的使用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.insert(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.insert(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(lock.tryLock()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</div><div class="line">                    arrayList.add(i);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></div><div class="line">            &#125;<span class="keyword">finally</span> &#123;</div><div class="line">                System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(thread.getName()+<span class="string">"获取锁失败"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Thread-0得到了锁</div><div class="line">Thread-1获取锁失败</div><div class="line">Thread-0释放了锁</div></pre></td></tr></table></figure></p>
<h5 id="例子3，lockInterruptibly"><a href="#例子3，lockInterruptibly" class="headerlink" title="例子3，lockInterruptibly()"></a>例子3，lockInterruptibly()</h5><p>响应中断的使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        Test test = <span class="keyword">new</span> Test();</div><div class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(test);</div><div class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(test);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        thread2.interrupt();</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        lock.lockInterruptibly();   <span class="comment">//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span></div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</div><div class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">            <span class="keyword">for</span>(    ;     ;) &#123;</div><div class="line">                <span class="keyword">if</span>(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="comment">//插入数据</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">finally</span> &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"执行finally"</span>);</div><div class="line">            lock.unlock();</div><div class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Test test = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Test test)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.test = test;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            test.insert(Thread.currentThread());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"被中断"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之后，发现thread2能够被正确中断。</p>
<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Returns the lock used for reading.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Returns the lock used for writing.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</p>
<p>　　下面通过几个例子来看一下ReentrantReadWriteLock具体用法。</p>
<p>　　假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：</p>
<h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.get(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.get(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">         </div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</div><div class="line">            System.out.println(thread.getName()+<span class="string">"正在进行读操作"</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。</p>
<h5 id="改成用读写锁"><a href="#改成用读写锁" class="headerlink" title="改成用读写锁"></a>改成用读写锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.get(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">         </div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.get(Thread.currentThread());</div><div class="line">            &#125;;</div><div class="line">        &#125;.start();</div><div class="line">         </div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">        rwl.readLock().lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">             </div><div class="line">            <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</div><div class="line">                System.out.println(thread.getName()+<span class="string">"正在进行读操作"</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            rwl.readLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0正在进行读操作</div><div class="line">Thread-1正在进行读操作</div><div class="line">Thread-0读操作完毕</div><div class="line">Thread-1读操作完毕</div></pre></td></tr></table></figure></p>
<p>说明thread1和thread2在同时进行读操作。</p>
<p>　　这样就大大提升了读操作的效率。</p>
<p>　　不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</p>
<p>　　如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p>
<p>　　关于ReentrantReadWriteLock类中的其他方法感兴趣的朋友可以自行查阅API文档。</p>
<h4 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h4><p>总结来说，Lock和synchronized有以下几点不同：</p>
<p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p>
<p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
<p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p>
<p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p>
<p>　　5）Lock可以提高多个线程进行读操作的效率。</p>
<p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<h3 id="锁的相关概念介绍"><a href="#锁的相关概念介绍" class="headerlink" title="锁的相关概念介绍"></a>锁的相关概念介绍</h3><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p>
<p>看下面这段代码就明白了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        method2();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p>
<p>　　而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。
　　</p>
<h4 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h4><p>可中断锁：顾名思义，就是可以相应中断的锁。</p>
<p>　　在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p>
<p>　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p>
<p>　　在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p>
<p>　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p>
<p>　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p>
<p>　　而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p>
<p>　　看一下这2个类的源代码就清楚了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Sync object for non-fair locks</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></div><div class="line"><span class="comment">     * acquire on failure.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">        <span class="keyword">else</span></div><div class="line">            acquire(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Sync object for fair locks</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></div><div class="line"><span class="comment">     * recursive call or no waiters or is first.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。</p>
<p>　　我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<p>如果参数为true表示为公平锁，为fasle为非公平锁。默认情况下，如果使用无参构造器，则是非公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></div><div class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></div><div class="line"><span class="comment"> * given fairness policy.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外在ReentrantLock类中定义了很多方法，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　isFair()        //判断锁是否是公平锁</div><div class="line"></div><div class="line">　　isLocked()    //判断锁是否被任何线程获取了</div><div class="line"></div><div class="line">　　isHeldByCurrentThread()   //判断锁是否被当前线程获取了</div><div class="line"></div><div class="line">　　hasQueuedThreads()   //判断是否有线程在等待该锁</div></pre></td></tr></table></figure></p>
<p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。</p>
<p>　　正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。</p>
<p>　　ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。</p>
<p>　　可以通过readLock()获取读锁，通过writeLock()获取写锁。</p>
<p>　　上面已经演示过了读写锁的使用方法，在此不再赘述。</p>
<p><strong>文章转载：<a rel="external nofollow" target="_blank" href="http://www.cnblogs.com/dolphin0520/p/3923167.html">海子</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取锁的线程执行完了该代码块，然后线程释放对锁的占有；&lt;/li&gt;
&lt;li&gt;线程执行发生异常，此时JVM会让线程自动释放锁。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程中synchronized</title>
    <link href="http://blog.wuwii.com/java-synchronized.html"/>
    <id>http://blog.wuwii.com/java-synchronized.html</id>
    <published>2017-11-05T02:08:03.000Z</published>
    <updated>2017-11-05T02:22:31.204Z</updated>
    
    <content type="html"><![CDATA[<p>在多线程中，当多个线程同时访问同一个资源对象的时候，由于线程在处理中是不可控的，导致，执行的结果可能出现不可控的错误。</p>
<p>例如：两个线程thread-1和thread-2，同时要数据入库，需要判断数据字段a，不重复，所以当插入数据的时候先去检查数据库中a字段，当我们的两个线程中字段a相同的时候，出现thread1先执行查询，在thread2查询，两个线程同时都会得到a字段没重复，这个时候，数据入库，肯定会有问题的。</p>
<p>有线程安全的问题，这个资源叫做<code>临界资源</code>。</p>
<a id="more"></a>
<p>当多个线程同时访问临界资源（一个对象，对象中的属性，一个文件，一个数据库等）时，就可能会产生线程安全问题。</p>
<p>解决办法有两个，一个是让线程同步synchronized， 一个是lock。</p>
<h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><p>使用 <code>synchronized</code>关键字来修饰一个方法和方法块，当线程访问这个对象的synchronized修饰的方法的时候，会锁住这个方法，其他线程无法访问，等待这个线程执行完毕，其他线程才排队进来依次执行，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.wuwii.test.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/5 9:39&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ThreadData threadData = <span class="keyword">new</span> ThreadData();</div><div class="line">        ThreadData threadData1 = <span class="keyword">new</span> ThreadData();</div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; threadData.data1()).start();</div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; ThreadData.data2()).start();</div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; threadData.data3()).start();</div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; threadData1.data1()).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadData</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">data1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"begin data1"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">3000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"end data1"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">data2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"data2"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">data3</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"begin data3"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"end data3"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">begin data1</div><div class="line">data2</div><div class="line">begin data1</div><div class="line">end data1</div><div class="line">begin data3</div><div class="line">end data1</div><div class="line">end data3</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。</li>
<li>如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。</li>
<li>如果一个线程执行一个对象的非static synchronized方法，另外一个线程需要执行这个对象所属类的static synchronized方法，此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，所以不存在互斥现象。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在多线程中，当多个线程同时访问同一个资源对象的时候，由于线程在处理中是不可控的，导致，执行的结果可能出现不可控的错误。&lt;/p&gt;
&lt;p&gt;例如：两个线程thread-1和thread-2，同时要数据入库，需要判断数据字段a，不重复，所以当插入数据的时候先去检查数据库中a字段，当我们的两个线程中字段a相同的时候，出现thread1先执行查询，在thread2查询，两个线程同时都会得到a字段没重复，这个时候，数据入库，肯定会有问题的。&lt;/p&gt;
&lt;p&gt;有线程安全的问题，这个资源叫做&lt;code&gt;临界资源&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://blog.wuwii.com/tags/hexo/"/>
    
  </entry>
  
</feed>
