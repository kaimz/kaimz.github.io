<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喃声细语</title>
  <subtitle>一个人的独白，成为最好的自己，遇到最好的那个人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.wuwii.com/"/>
  <updated>2017-12-06T03:57:20.658Z</updated>
  <id>http://blog.wuwii.com/</id>
  
  <author>
    <name>Slience</name>
    <email>k@wuwii.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里巴巴Java开发手册中容易踩的坑</title>
    <link href="http://blog.wuwii.com/alibaba-java-prochip.html"/>
    <id>http://blog.wuwii.com/alibaba-java-prochip.html</id>
    <published>2017-12-06T03:48:03.000Z</published>
    <updated>2017-12-06T03:57:20.658Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴Java开发手册地址：<a rel="external nofollow" target="_blank" href="https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BA%AA%E5%BF%B5%E7%89%88%EF%BC%89.pdf">阿里巴巴Java开发手册（纪念版）.pdf</a></p>
<p>开始看的时候还是<strong>终极版</strong>，不知道什么时候又出到了<strong>纪念版</strong>，听说之前还有个<strong>完美版</strong>，感觉词穷了，期待下一版本<strong>狗年限定版</strong>。<br>撇开了，<strong>很实用的规范内容，值得看</strong>。</p>
<p>记录下个人容易出问题的地方。</p>
<hr>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><h4 id="各层命名规约"><a href="#各层命名规约" class="headerlink" title="各层命名规约"></a>各层命名规约</h4><h5 id="Service-DAO-层方法命名规约"><a href="#Service-DAO-层方法命名规约" class="headerlink" title="Service/DAO 层方法命名规约"></a>Service/DAO 层方法命名规约</h5><ol>
<li>获取单个对象的方法用 get 做前缀。   </li>
<li>获取多个对象的方法用 list 做前缀。  </li>
<li>获取统计值的方法用 count 做前缀。   </li>
<li>插入的方法用 save/insert 做前缀。   </li>
<li>删除的方法用 remove/delete 做前缀。    </li>
<li>修改的方法用 update 做前缀。 </li>
</ol>
<h5 id="领域模型命名规约"><a href="#领域模型命名规约" class="headerlink" title="领域模型命名规约"></a>领域模型命名规约</h5><ol>
<li>数据对象：xxxDO，xxx 即为数据表名。    </li>
<li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。 </li>
<li>展示对象：xxxVO，xxx 一般为网页名称。  </li>
<li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 </li>
</ol>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><ol>
<li>不允许任何魔法值（即未经定义的常量）直接出现在代码中。 </li>
<li>将包或者工程内部的共享变量，放在相应的constant 下，例如，一个模块下的常量：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.renren.utils;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 常量</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2016年11月15日 下午1:23:52</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> </span>&#123;</div><div class="line">	<span class="comment">/** 超级管理员ID */</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUPER_ADMIN = <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * 菜单类型</span></div><div class="line"><span class="comment">	 * </span></div><div class="line"><span class="comment">	 * <span class="doctag">@date</span> 2016年11月15日 下午1:24:29</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> MenuType &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 目录</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    	CATALOG(<span class="number">0</span>),</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 菜单</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        MENU(<span class="number">1</span>),</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 按钮</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        BUTTON(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">MenuType</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时任务状态</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ScheduleStatus &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 正常</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    	NORMAL(<span class="number">0</span>),</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 暂停</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    	PAUSE(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ScheduleStatus</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 云服务商</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> CloudService &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 七牛云</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        QINIU(<span class="number">1</span>),</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 阿里云</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        ALIYUN(<span class="number">2</span>),</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 腾讯云</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        QCLOUD(<span class="number">3</span>);</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CloudService</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="OOP归约"><a href="#OOP归约" class="headerlink" title="OOP归约"></a>OOP归约</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p>
<ul>
<li>正例：”test”.equals(object); </li>
<li>反例：object.equals(“test”); </li>
<li>说明：推荐使用 java.util.Objects#equals（JDK7 引入的工具类）。</li>
</ul>
<hr>
<p>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 </p>
<ul>
<li>说明：对于 Integer var = ?  在-128 至 127 范围内的赋值，Integer 对象是在<br>IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行 判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑， 推荐使用 equals 方法进行判断。</li>
</ul>
<hr>
<p>关于基本数据类型与包装数据类型的使用标准如下： </p>
<ul>
<li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li>
<li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。 </li>
<li><p>【推荐】所有的局部变量使用基本数据类型。</p>
<ul>
<li>说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</li>
<li>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。  </li>
<li>反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用 不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装 数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 </li>
</ul>
</li>
</ul>
<hr>
<p> 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&gt; generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。</p>
<p> 说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排 查问题。 </p>
<hr>
<p> 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。 </p>
<p> 说明：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"a,b,c,,"</span>; </div><div class="line">String[] ary = str.split(<span class="string">","</span>); </div><div class="line"><span class="comment">// 预期大于 3，结果是 3</span></div><div class="line">System.out.println(ary.length);</div></pre></td></tr></table></figure></p>
<hr>
<p> 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字： </p>
<ol>
<li>不允许被继承的类，如：String 类。 </li>
<li>不允许修改引用的域对象，如：POJO 类的域变量。  </li>
<li>不允许被重写的方法，如：POJO 类的 setter 方法。 </li>
<li>不允许运行过程中重新赋值的局部变量。</li>
<li>避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好 地进行重构。 </li>
</ol>
<hr>
<p>【推荐】类成员与方法访问控制从严： </p>
<ol>
<li>如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。  </li>
<li>工具类不允许有 public 或 default 构造方法。  </li>
<li>类非 static 成员变量并且与子类共享，必须是 protected。  </li>
<li>类非 static 成员变量并且仅在本类使用，必须是 private。</li>
<li>类 static 成员变量如果仅在本类使用，必须是 private。 </li>
<li>若是 static 成员变量，必须考虑是否为 final。  </li>
<li>类成员方法只供类内部调用，必须是 private。</li>
<li>类成员方法只对继承类公开，那么限制为 protected。 </li>
</ol>
<ul>
<li>说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。 思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 方法，或者 一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的 视线内，变量作用域太大，无限制的到处跑，那么你会担心的。 </li>
</ul>
<h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><p>【强制】关于 hashCode 和 equals 的处理，遵循如下规则：</p>
<ol>
<li>只要重写 equals，就必须重写 hashCode。 </li>
<li>因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的 对象必须重写这两个方法。</li>
<li>如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。 说明：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象 作为 key 来使用。</li>
</ol>
<p>没有特需要求，使用编辑器自动生成的就好，这个对Hash表相关的数据结构的存储和读取有着很大的影响，重写的好，可以减少Hash碰撞。</p>
<hr>
<ul>
<li>【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全 一样的数组，大小就是 list.size()。 </li>
<li>说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配 内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组 元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素 个数一致。 </li>
<li>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它 类型数组将出现 ClassCastException 错误。 </li>
<li>正例： <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">2</span>);   </div><div class="line">list.add(<span class="string">"guan"</span>);      </div><div class="line">list.add(<span class="string">"bao"</span>);      </div><div class="line">String[] array = <span class="keyword">new</span> String[list.size()];    </div><div class="line">array = list.toArray(array);</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方 法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。 说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] str = new String[] &#123; &quot;you&quot;, &quot;wu&quot; &#125;;  </div><div class="line">List list = Arrays.asList(str);</div></pre></td></tr></table></figure></p>
<ul>
<li>第一种情况：list.add(“yangguanbao”); 运行时异常。</li>
<li>第二种情况：str[0] = “gujin”; 那么 list.get(0)也会随之修改。 </li>
</ul>
<hr>
<p>【强制】泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据，此写法的泛型集合不能使用 add 方 法，而<code>&lt;? super T&gt;</code>不能使用 get 方法，做为接口调用赋值时易出错。 </p>
<hr>
<p>【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。 </p>
<ul>
<li>正例： <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; iterator = list.iterator();  </div><div class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;              </div><div class="line">    String item = iterator.next();                       </div><div class="line">    <span class="keyword">if</span> (删除元素的条件) &#123;                              </div><div class="line">        iterator.remove();                 </div><div class="line">    &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort， Collections.sort 会报 IllegalArgumentException 异常。 说明：三个条件如下</p>
<ol>
<li>x，y 的比较结果和 y，x 的比较结果相反。 </li>
<li>x&gt;y，y&gt;z，则 x&gt;z。 </li>
<li>x=y，则 x，z 比较结果和 y，z 比较结果相同。 </li>
</ol>
<ul>
<li>反例：下例中没有处理相等的情况，实际使用中可能会出现异常： <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;      </div><div class="line">    <span class="meta">@Override</span>         </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;    </div><div class="line">        <span class="keyword">return</span> o1.getId() &gt; o2.getId() ? <span class="number">1</span> : -<span class="number">1</span>;        </div><div class="line">    &#125;      </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。 </p>
<ul>
<li>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效 率更高。如果是 JDK8，使用 Map.foreach 方法。 </li>
<li>正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是 一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。 </li>
</ul>
<hr>
<p>【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格： </p>
<table>
<thead>
<tr>
<th>集合类</th>
<th>Key</th>
<th>Value</th>
<th>Super</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>Dictionary</td>
<td>线程安全 </td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>AbstractMap</td>
<td>锁分段技术（JDK8:CAS） </td>
</tr>
<tr>
<td>TreeMap</td>
<td>不允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全 </td>
</tr>
<tr>
<td>HashMap</td>
<td>允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全 </td>
</tr>
</tbody>
</table>
<ul>
<li>反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上， 存储 null 值时会抛出 NPE 异常。 </li>
</ul>
<hr>
<p>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和 不稳定性(unorder)带来的负面影响。 </p>
<ul>
<li>说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次 序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。 </li>
</ul>
<hr>
<p>【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。 </p>
<h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><p>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 说明：资源驱动类、工具类、单例工厂类都需要注意。 </p>
<hr>
<p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 返回的线程池对象的弊端如下：</p>
<ol>
<li>FixedThreadPool 和 SingleThreadPool:   允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </li>
<li>CachedThreadPool 和 ScheduledThreadPool:   允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 </li>
</ol>
<hr>
<p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。 </p>
<hr>
<p> 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。 </p>
<ul>
<li>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序 也必须是 A、B、C，否则可能出现死锁。</li>
</ul>
<hr>
<p>【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行 至 await 方法，直到超时才返回结果。</p>
<ul>
<li>说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</li>
</ul>
<hr>
<p>【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优 化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐解 决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。 </p>
<hr>
<p>【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题， 但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现： AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推 荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。 </p>
<hr>
<p>【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享 此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只 要是这个线程内定义的)都可以操控这个变量。 </p>
<hr>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免采用 单行的编码方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (condition) statements;</div></pre></td></tr></table></figure></p>
<hr>
<p>超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现</p>
<hr>
<p>【参考】下列情形，需要进行参数校验： </p>
<ol>
<li>调用频次低的方法。  </li>
<li>执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参 数错误导致中间执行回退，或者错误，那得不偿失。  </li>
<li>需要极高稳定性和可用性的方法。 </li>
<li>对外提供的开放接口，不管是 RPC/API/HTTP 接口。  </li>
<li>敏感权限入口。 </li>
</ol>
<hr>
<p>【参考】下列情形，不需要进行参数校验： </p>
<ol>
<li>极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。  </li>
<li>底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底 层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所 以 DAO 的参数校验，可以省略。 </li>
<li>被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参 数已经做过检查或者肯定不会有问题，此时可以不校验参数。 </li>
</ol>
<h3 id="注释归约"><a href="#注释归约" class="headerlink" title="注释归约"></a>注释归约</h3><p>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</p>
<ol>
<li>待办事宜<code>（TODO）</code>:<code>（ 标记人，标记时间，[预计处理时间]）</code>    表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。</li>
<li>错误，不能工作<code>（FIXME）</code>:<code>（标记人，标记时间，[预计处理时间]）</code>    在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 </li>
</ol>
<hr>
<p>【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分 说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。 说明：本手册明确<strong>防止 NPE 是调用者的责任</strong>。即使被调用方法返回空集合或者空对象，对调用<br>者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。 </p>
<hr>
<p> 【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：  </p>
<ol>
<li>返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。     反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。 </li>
<li>数据库的查询结果可能为 null。  </li>
<li>集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。  </li>
<li>远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</li>
<li>对于 Session 中获取的数据，建议 NPE 检查，避免空指针。</li>
<li>级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。 </li>
</ol>
<ul>
<li>正例：<strong>使用 JDK8 的 Optional 类来防止 NPE 问题。</strong></li>
</ul>
<hr>
<p>【推荐】定义时区分 unchecked / checked 异常，<strong>避免直接抛出 new RuntimeException()， 更不允许抛出 Exception 或者 Throwable</strong>，应使用有业务含义的自定义异常。推荐业界已定义 过的自定义异常，如：DAOException / ServiceException 等。 </p>
<hr>
<p>【参考】<strong>避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则</strong>。</p>
<ul>
<li>说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副 本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 </li>
<li>正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取</li>
</ul>
<h2 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h2><p>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.slf4j.Logger; </div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Abc.class);</div></pre></td></tr></table></figure></p>
<hr>
<p>【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。 </p>
<ul>
<li>说明：logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol); 如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象， 会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 </li>
<li><p>正例：（条件） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;    </div><div class="line">    logger.debug(<span class="string">"Processing trade with id: "</span> + id + <span class="string">" and symbol: "</span> + symbol);   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>正例：（占位符） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logger.debug(<span class="string">"Processing trade with id: &#123;&#125; and symbol : &#123;&#125; "</span>, id, symbol);</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 <code>additivity=false</code></p>
<hr>
<p>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。 </p>
<ul>
<li>正例：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logger.error(各类参数或者对象 toString + <span class="string">"_"</span> + e.getMessage(), e);</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适 从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必 要，请不要在此场景打出 error 级别。 </p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>【强制】好的单元测试必须遵守<code>AIR 原则</code>。 说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上， 却是非常关键的。好的单元测试宏观上来说，<strong>具有自动化、独立性、可重复执行的特点。</strong></p>
<ul>
<li><code>A</code>：Automatic（自动化） </li>
<li><code>I</code>：Independent（独立性） </li>
<li><code>R</code>：Repeatable（可重复） </li>
</ul>
<hr>
<p>【强制】单元测试应该是全自动执行的，并且非交互式的。测试框架通常是定期执行的，执行 过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。<strong>单元测 试中不准使用 <code>System.out```来进行人肉验证，必须使用</code>assert`` 来验证。</strong> </p>
<hr>
<p>【推荐】单元测试的基本目标：<strong>语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都 要达到 100%</strong></p>
<ul>
<li>说明：在工程规约的应用分层中提到的 DAO 层，Manager 层，可重用度高的 Service，都应该 进行单元测试。 </li>
</ul>
<hr>
<p>【推荐】编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。 </p>
<ul>
<li><strong>B</strong>：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li>
<li><strong>C</strong>：Correct，正确的输入，并得到预期的结果。 </li>
<li><strong>D</strong>：Design，与设计文档相结合，来编写单元测试。 </li>
<li><strong>E</strong>：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得 到预期的结果。</li>
</ul>
<hr>
<p>【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的， 或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。 </p>
<ul>
<li>反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这 一行新增数据并不符合业务插入规则，导致测试结果异常。</li>
</ul>
<hr>
<p>【推荐】<strong>和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者 对单元测试产生的数据有明确的前后缀标识</strong>。 </p>
<ul>
<li>正例：在 RDC 内部单元测试中，使用 RDC_UNIT<em>TEST</em>的前缀标识数据。 </li>
</ul>
<hr>
<p>【推荐】<strong>对于不可测的代码建议做必要的重构，使代码变得可测</strong>，避免为了达到测试要求而 书写不规范测试代码。 </p>
<hr>
<p>【参考】为了更方便地进行单元测试，业务代码应避免以下情况： </p>
<ul>
<li>构造方法中做的事情过多。 </li>
<li>存在过多的全局变量和静态方法。 </li>
<li>存在过多的外部依赖。</li>
<li>存在过多的条件语句。</li>
</ul>
<p><strong>说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</strong> </p>
<hr>
<p>【参考】不要对单元测试存在如下误解： </p>
<ul>
<li>那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。 </li>
<li>单元测试代码是多余的。汽车的整体功能与各单元部件的测试正常与否是强相关的。 </li>
<li>单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。</li>
<li>单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。 </li>
</ul>
<h2 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h2><p>【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。</p>
<ul>
<li>说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信 内容、修改他人的订单。 </li>
</ul>
<hr>
<p>【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。 </p>
<ul>
<li>说明：查看个人手机号码会显示成:158<em>**</em>9119，隐藏中间 4 位，防止隐私泄露。 </li>
</ul>
<hr>
<p> 【强制】用户请求传入的任何参数必须做有效性验证。</p>
<ul>
<li>说明：忽略参数校验可能导致： <ul>
<li>page size 过大导致内存溢出 </li>
<li>恶意 order by 导致数据库慢查询 </li>
<li>任意重定向  SQL 注入 </li>
<li>反序列化注入 </li>
<li>正则输入源串拒绝服务 ReDoS </li>
</ul>
</li>
</ul>
<p><strong>说明</strong>：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题， 但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p>
<hr>
<p>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的<strong>防重放限制</strong>， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 </p>
<ul>
<li>说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其 它用户，并造成短信平台资源浪费。</li>
</ul>
<hr>
<p>【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须<strong>实现防刷、文本内容违禁词过 滤等风控策略</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿里巴巴Java开发手册地址：&lt;a rel=&quot;external nofollow&quot; target=&quot;_blank&quot; href=&quot;https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>BeanUtils的复制</title>
    <link href="http://blog.wuwii.com/spring-beanutils.html"/>
    <id>http://blog.wuwii.com/spring-beanutils.html</id>
    <published>2017-12-03T14:08:03.000Z</published>
    <updated>2017-12-05T03:08:13.981Z</updated>
    
    <content type="html"><![CDATA[<p>有一个子类继承了父类的属性，但是有很多属性值需要复制，单纯的靠set 或者构造函数肯定很不美观，出于“懒”的目的，了解到spring beans里面提供了BeanUtils工具类，看下copyProperties方法满足需要，是用反射做的。</p>
<a id="more"></a>
<h4 id="方法源码"><a href="#方法源码" class="headerlink" title="方法源码"></a>方法源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">	 * Copy the property values of the given source bean into the given target bean.</span></div><div class="line"><span class="comment">	 * &lt;p&gt;Note: The source and target classes do not have to match or even be derived</span></div><div class="line"><span class="comment">	 * from each other, as long as the properties match. Any bean properties that the</span></div><div class="line"><span class="comment">	 * source bean exposes but the target bean does not will silently be ignored.</span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> source the source bean</span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> target the target bean</span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> editable the class (or interface) to restrict property setting to</span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> ignoreProperties array of property names to ignore</span></div><div class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the copying failed</span></div><div class="line"><span class="comment">	 * <span class="doctag">@see</span> BeanWrapper</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target, Class&lt;?&gt; editable, String... ignoreProperties)</span></span></div><div class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line"></div><div class="line">		Assert.notNull(source, <span class="string">"Source must not be null"</span>);</div><div class="line">		Assert.notNull(target, <span class="string">"Target must not be null"</span>);</div><div class="line"></div><div class="line">		Class&lt;?&gt; actualEditable = target.getClass();</div><div class="line">		<span class="keyword">if</span> (editable != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (!editable.isInstance(target)) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target class ["</span> + target.getClass().getName() +</div><div class="line">						<span class="string">"] not assignable to Editable class ["</span> + editable.getName() + <span class="string">"]"</span>);</div><div class="line">			&#125;</div><div class="line">			actualEditable = editable;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//获取targetCLass所有属性及属性的它set,get的方法，描述属性</span></div><div class="line">		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</div><div class="line">		List&lt;String&gt; ignoreList = (ignoreProperties != <span class="keyword">null</span> ? Arrays.asList(ignoreProperties) : <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        <span class="comment">//遍历每个属性</span></div><div class="line">		<span class="keyword">for</span> (PropertyDescriptor targetPd : targetPds) &#123;</div><div class="line">		    <span class="comment">//根据 这个属性 获取目标类的set方法</span></div><div class="line">			Method writeMethod = targetPd.getWriteMethod();</div><div class="line">			<span class="comment">//检测</span></div><div class="line">			<span class="keyword">if</span> (writeMethod != <span class="keyword">null</span> &amp;&amp; (ignoreList == <span class="keyword">null</span> || !ignoreList.contains(targetPd.getName()))) &#123;</div><div class="line">				<span class="comment">// 获取 源类 的相应的描述属性</span></div><div class="line">				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</div><div class="line">				<span class="keyword">if</span> (sourcePd != <span class="keyword">null</span>) &#123;</div><div class="line">				    <span class="comment">// 获取源类的get方法</span></div><div class="line">					Method readMethod = sourcePd.getReadMethod();</div><div class="line">					<span class="comment">//检测方法，然后获取值，写入</span></div><div class="line">					<span class="keyword">if</span> (readMethod != <span class="keyword">null</span> &amp;&amp;</div><div class="line">							ClassUtils.isAssignable(writeMethod.getParameterTypes()[<span class="number">0</span>], readMethod.getReturnType())) &#123;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">							<span class="keyword">if</span> (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</div><div class="line">								readMethod.setAccessible(<span class="keyword">true</span>);</div><div class="line">							&#125;</div><div class="line">							Object value = readMethod.invoke(source);</div><div class="line">							<span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</div><div class="line">								writeMethod.setAccessible(<span class="keyword">true</span>);</div><div class="line">							&#125;</div><div class="line">							writeMethod.invoke(target, value);</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(</div><div class="line">									<span class="string">"Could not copy property '"</span> + targetPd.getName() + <span class="string">"' from source to target"</span>, ex);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>方法前面的文档告诉了我们：将源Bean复制到指定的Bean中，两个类不需要有关联，也不必是派生关系，只需要属性匹配即可。</p>
<h4 id="学习代码"><a href="#学习代码" class="headerlink" title="学习代码"></a>学习代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.devframe.util;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/12/1 14:13&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeans</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//首先设置一个学生，将它的基本属性复制给大学生，很方便的操作，不用set</span></div><div class="line">            Student student = <span class="keyword">new</span> Student(<span class="string">"wuwii"</span>, <span class="keyword">new</span> Date(<span class="number">1994</span> - <span class="number">1990</span>, <span class="number">2</span> -<span class="number">1</span>, <span class="number">19</span>),</div><div class="line">                    <span class="string">"WuHan"</span>, <span class="string">"123456"</span>);</div><div class="line">            UniversityStudent universityStudent = <span class="keyword">new</span> UniversityStudent();</div><div class="line">            BeanUtils.copyProperties(student, universityStudent);</div><div class="line">            System.out.println(universityStudent);</div><div class="line"></div><div class="line">            <span class="comment">//源和目标没有关联，部分属性也可以复制，有些属性没有也行。</span></div><div class="line">            String[] ignoreProperties = &#123;<span class="string">"name"</span>&#125;;</div><div class="line">            Adult_ adult = <span class="keyword">new</span> Adult_();</div><div class="line">            BeanUtils.copyProperties(student, adult, ignoreProperties);</div><div class="line">            System.out.printf(<span class="string">"adule： %s%n"</span>, adult);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//还有一些其他的实用方法</span></div><div class="line"></div><div class="line">        <span class="comment">//建立一个字符串Date</span></div><div class="line">        String date = <span class="string">"2008-8-8"</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 学生实体</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 姓名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 出生年月</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date birthDate;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 住址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String address;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 身份证号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String IDNumber;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, Date birthDate, String address, String IDNumber)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.birthDate = birthDate;</div><div class="line">        <span class="keyword">this</span>.address = address;</div><div class="line">        <span class="keyword">this</span>.IDNumber = IDNumber;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// copyProperties是调用的set方法</span></div><div class="line">    <span class="comment">/*public void setName(String name) &#123;</span></div><div class="line"><span class="comment">        this.name = "keen";</span></div><div class="line"><span class="comment">    &#125;*/</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> birthDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthDate</span><span class="params">(Date birthDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.birthDate = birthDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.address = address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIDNumber</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> IDNumber;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIDNumber</span><span class="params">(String IDNumber)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.IDNumber = IDNumber;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</div><div class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", birthDate="</span> + birthDate +</div><div class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", IDNumber='"</span> + IDNumber + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 大学生继承学生&lt;/br&gt;</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniversityStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 专业</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String major;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMajor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> major;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMajor</span><span class="params">(String major)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.major = major;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">" UniversityStudent&#123;"</span> +</div><div class="line">                <span class="string">"major='"</span> + major + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 成年人</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adult_</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 姓名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 出生年月</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date birthDate;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adult_</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adult_</span><span class="params">(String name, Date birthDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.birthDate = birthDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> birthDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthDate</span><span class="params">(Date birthDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.birthDate = birthDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Adult_&#123;"</span> +</div><div class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", birthDate="</span> + birthDate +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Student&#123;name=&apos;wuwii&apos;, birthDate=Fri Feb 19 00:00:00 CST 1904, address=&apos;WuHan&apos;, IDNumber=&apos;123456&apos;&#125; UniversityStudent&#123;major=&apos;null&apos;&#125;</div><div class="line">adule： Adule_&#123;name=&apos;null&apos;, birthDate=Fri Feb 19 00:00:00 CST 1904&#125;</div></pre></td></tr></table></figure></p>
<p>出如反射机制的性能问题，如果有要求的话，还是建议使用构造函数吧，或者更换设计。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个子类继承了父类的属性，但是有很多属性值需要复制，单纯的靠set 或者构造函数肯定很不美观，出于“懒”的目的，了解到spring beans里面提供了BeanUtils工具类，看下copyProperties方法满足需要，是用反射做的。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>20171203</title>
    <link href="http://blog.wuwii.com/omelette.html"/>
    <id>http://blog.wuwii.com/omelette.html</id>
    <published>2017-12-03T12:08:03.000Z</published>
    <updated>2017-12-04T00:27:53.611Z</updated>
    
    <content type="html"><![CDATA[<p>周末宅了下，肚子就饿得不行呀，动下手做点吃的，第一次做坑的不行啊。</p>
<a id="more"></a>
<p><img src="http://image.wuwii.com/omelette-1.jpg" alt="image"><br><img src="http://image.wuwii.com/omelette-2.jpg" alt="image"><br><img src="http://image.wuwii.com/omelette-3.jpg" alt="image"></p>
<p>这么多，傻眼了，糊了糊了。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末宅了下，肚子就饿得不行呀，动下手做点吃的，第一次做坑的不行啊。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>事务的特性和@Transactional注解的使用</title>
    <link href="http://blog.wuwii.com/java-transactional.html"/>
    <id>http://blog.wuwii.com/java-transactional.html</id>
    <published>2017-11-30T08:08:03.000Z</published>
    <updated>2017-12-04T00:27:53.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Transactional如何工作"><a href="#Transactional如何工作" class="headerlink" title="@Transactional如何工作"></a>@Transactional如何工作</h3><p>实现了EntityManager接口的持久化上下文代理并不是声明式事务管理的唯一部分，事实上包含三个组成部分：</p>
<ol>
<li>事务的切面</li>
<li>事务管理器</li>
<li>EntityManager Proxy本身</li>
</ol>
<a id="more"></a>
<h4 id="事务切面"><a href="#事务切面" class="headerlink" title="事务切面"></a>事务切面</h4><p>事务的切面是一个“around（环绕）”切面，在注解的业务方法前后都可以被调用。实现切面的具体类是<code>TransactionInterceptor</code>。</p>
<p>事务的切面的主要职责：<br>在’before’时，切面提供一个调用点，来决定被调用业务方法应该在正在进行事务的范围内运行，还是开始一个新的独立事务。<br>在’after’时，切面需要确定事务被提交，回滚或者继续运行。<br>在’before’时，事务切面自身不包含任何决策逻辑，是否开始新事务的决策委派给事务管理器完成。</p>
<ul>
<li>新的Entity Manager是否应该被创建？</li>
<li>是否应该开始新的事务？</li>
</ul>
<p><strong>这些需要事务切面’before’逻辑被调用时决定。事务管理器的决策基于以下两点：</strong></p>
<ol>
<li>事务是否正在进行；</li>
<li>事务方法的propagation属性（比如REQUIRES_NEW总要开始新事务）。</li>
</ol>
<h4 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h4><p>如果事务管理器确定要创建新事务，那么将：</p>
<p>创建一个新的entity manager<br>entity manager绑定到当前线程<br>从数据库连接池中获取连接<br>将连接绑定到当前线程<br>使用ThreadLocal变量将entity manager和数据库连接都绑定到当前线程。</p>
<p>事务运行时他们存储在线程中，当它们不再被使用时，事务管理器决定是否将他们清除。</p>
<p>程序的任何部分如果需要当前的entity manager和数据库连接都可以从线程中获取。</p>
<h4 id="EntityManager-proxy"><a href="#EntityManager-proxy" class="headerlink" title="EntityManager proxy"></a>EntityManager proxy</h4><p>当业务方法调用entityManager.persist()时，这不是由entity manager直接调用的。<br>而是业务方法调用代理，代理从线程获取当前的entity manager事务管理器将entity manager绑定到线程。</p>
<h3 id="spring-中配置JPA事务"><a href="#spring-中配置JPA事务" class="headerlink" title="spring 中配置JPA事务"></a>spring 中配置JPA事务</h3><p>在spring 的配置文件中配置jpa的事务：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Jpa 事务管理器 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.JpaTransactionManager"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"entityManagerFactory"</span> <span class="attr">ref</span>=<span class="string">"entityManagerFactory"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 打开事务注解 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>当然可以使用aop配置事务：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Jpa 事务管理器 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.JpaTransactionManager"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"entityManagerFactory"</span> <span class="attr">ref</span>=<span class="string">"entityManagerFactory"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 声明式事务配置 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">propagation</span>=<span class="string">"NOT_SUPPORTED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"count*"</span> <span class="attr">propagation</span>=<span class="string">"NOT_SUPPORTED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"NOT_SUPPORTED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"query*"</span> <span class="attr">propagation</span>=<span class="string">"NOT_SUPPORTED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 只对业务逻辑层实施事务--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"txPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.devframe.service.impl.*.*(..))"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPointcut"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="spring中事务的几个特性"><a href="#spring中事务的几个特性" class="headerlink" title="spring中事务的几个特性"></a>spring中事务的几个特性</h3><p><strong>补充下，数据库中的事务的四大特性：</strong></p>
<ul>
<li><code>原子性（Atomicity）</code>：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
<li><code>一致性（Consistency）</code>：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</li>
<li><code>隔离性（Isolation）</code>：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
<li><code>持久性（Durability）</code>：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>隔离级别是指若干个并发的事务之间的隔离程度。<code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li><code>TransactionDefinition.ISOLATION_DEFAULT</code>：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li>
<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</li>
<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li>
<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</li>
<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<p><strong>补充下数据库中，如果不考虑事务的隔离性，会发生的几种问题：</strong></p>
<ul>
<li><code>脏读</code>：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。<br>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</li>
<li><code>不可重复读</code>：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。<br>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。<br>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。<br>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</li>
<li><code>虚读(幻读)</code>：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</li>
</ul>
<h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量：</p>
<ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRED</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li>
<li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
<li><code>TransactionDefinition.PROPAGATION_MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li><code>TransactionDefinition.PROPAGATION_NESTED</code>：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<p>选择默认的，即<code>PROPAGATION_REQUIRED</code>，事务具有传播机制，多个事务，对于已经存在的事务，下一个事务会加入当前事务。</p>
<h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p>
<p>默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。</p>
<h4 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h4><p>只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。 默认为读写事务。</p>
<p><em>“只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。<br>但是你非要在“只读事务”里面修改数据，也并非不可以，只不过对于数据一致性的保护不像“读写事务”那样保险而已。<br>因此，“只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。</em></p>
<h4 id="spring事务回滚规则"><a href="#spring事务回滚规则" class="headerlink" title="spring事务回滚规则"></a>spring事务回滚规则</h4><p>指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。</p>
<p>默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务。还可以编程性的通过setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚。</p>
<h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>String</td>
<td>可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td>propagation</td>
<td>enum: Propagation</td>
<td>可选的事务传播行为设置</td>
</tr>
<tr>
<td>isolation</td>
<td>enum: Isolation</td>
<td>可选的事务隔离级别设置</td>
</tr>
<tr>
<td>readOnly</td>
<td>boolean</td>
<td>读写或只读事务，默认读写</td>
</tr>
<tr>
<td>timeout</td>
<td>int (in seconds granularity)</td>
<td>事务超时时间设置</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody>
</table>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p> @Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>
<p>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>
<p>默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为。</p>
<p>只要方法内部抛出<code>rollbackFor</code>设置的异常，就会回滚。</p>
<p>例如：<br>在方法上加上<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Transactional</span>(value=<span class="string">"transactionManager"</span>, rollbackFor = Exception.class)</div></pre></td></tr></table></figure></p>
<p>方法内部只要抛出指定的异常或者错误，就全部回滚。</p>
<p>补充，回滚异常是自己定义的异常类，最好按照要求继承<code>RuntimeException</code>。<br>如果非常有必要在事务中捕捉异常，而且需要回滚事务，那么直接再将这个异常抛出就可以了，但是不建议这么使用。</p>
<p><strong>参考文章：</strong></p>
<ul>
<li><a rel="external nofollow" target="_blank" href="http://blog.csdn.net/bao19901210/article/details/41724355">spring事物配置，声明式事务管理和基于@Transactional注解的使用</a></li>
<li><a rel="external nofollow" target="_blank" href="https://www.cnblogs.com/wangyonglong/p/5178450.html">JPA和事务管理</a></li>
<li><a rel="external nofollow" target="_blank" href="http://blog.csdn.net/hy6688_/article/details/44763869">Spring事务传播特性的浅析——事务方法嵌套调用的迷茫</a></li>
<li><a rel="external nofollow" target="_blank" href="https://www.cnblogs.com/fjdingsd/p/5273008.html">数据库事务的四大特性以及事务的隔离级别</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Transactional如何工作&quot;&gt;&lt;a href=&quot;#Transactional如何工作&quot; class=&quot;headerlink&quot; title=&quot;@Transactional如何工作&quot;&gt;&lt;/a&gt;@Transactional如何工作&lt;/h3&gt;&lt;p&gt;实现了EntityManager接口的持久化上下文代理并不是声明式事务管理的唯一部分，事实上包含三个组成部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务的切面&lt;/li&gt;
&lt;li&gt;事务管理器&lt;/li&gt;
&lt;li&gt;EntityManager Proxy本身&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>心底最柔软的爱</title>
    <link href="http://blog.wuwii.com/love-of-soft.html"/>
    <id>http://blog.wuwii.com/love-of-soft.html</id>
    <published>2017-11-29T15:08:03.000Z</published>
    <updated>2017-11-30T00:37:33.995Z</updated>
    
    <content type="html"><![CDATA[<p>晚上老妈又打电话给我了，其实前几天赶回去了一次，问我这边怎么样……</p>
<p>记得以前总没好好吃饭，喜欢吃零食，弄得身体一直不是很好；喜欢玩游戏，不喜欢学习；很任性……总是忽略了爸妈的好，可能总是以为理所当然了。慢慢得懂了，其实爸妈的爱是理所当然的，但，是那种最笨拙的，最柔软的爱，也是要我们珍惜和回报的，因为他们不能陪我们度过一生，需要每个人才能完美。</p>
<p>记得给老爸买智能手机后，他说他要玩微信，但是他还不太会玩智能手机，帮他下好几个常用的软件，而且让我调成手写输入法，虽然慢慢的，一个一个字的划着输入，看得到他是真的高兴。老妈很少用手机的，虽然后来也给她买了个手机，回到家的时候也教她用，但是老妈真的很不喜欢玩手机耶。</p>
<p>其实老爸的斗地主很厉害的，但是没时间玩，现在有手机了，可以经常玩了；喜欢看新闻，现在看天气，很准的，总算不用多年前的12121了。</p>
<p>即使在现在长大成人了，爸妈还是总是来问衣服够不够穿；是的，在父母的眼里，孩子不管多大，永远都是小孩，做父母的总会把孩子成长的每个细节都记在心里；可能年轻人总是笨手笨脚的，还真的有点不会照顾后自己，才让父母还是如此操心的吧。</p>
<p>其实，都懂，长大了，我会好好的。尽管你们爱的笨拙，触动最柔软的部分，我也是会流泪的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;晚上老妈又打电话给我了，其实前几天赶回去了一次，问我这边怎么样……&lt;/p&gt;
&lt;p&gt;记得以前总没好好吃饭，喜欢吃零食，弄得身体一直不是很好；喜欢玩游戏，不喜欢学习；很任性……总是忽略了爸妈的好，可能总是以为理所当然了。慢慢得懂了，其实爸妈的爱是理所当然的，但，是那种最笨拙的，
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>《嘉年华》的一点感想</title>
    <link href="http://blog.wuwii.com/angels-wear-white.html"/>
    <id>http://blog.wuwii.com/angels-wear-white.html</id>
    <published>2017-11-28T14:08:03.000Z</published>
    <updated>2017-12-04T00:27:53.596Z</updated>
    
    <content type="html"><![CDATA[<p>看了嘉年华，这次没去电影院，主要是周末一直有事情，是通过网上非正规渠道看的，网址就不暴露了，私聊也不给。</p>
<p>感觉今年也贡献了好多张电影票了，实在是现在电影看得爆米花形式的，我只想去上厕所……</p>
<p>这个电影还是没打算去电影院看，一个人去看电影好无聊呀；它是一个以女性的口吻来贯穿的。通过这个“幼女性侵”去讲述这个当前社会下这类人的生活状况。给人很大的震撼。</p>
<a id="more"></a>
<p>电影中小文和新新，经历这个恶魔的桥段，她们在什么都不懂的情况下，身边的人却对她们的排斥，父母的异样，政府和社会的妥协，让社会底层的人只能忍气吞声，最终她们渐渐的脱离了这个社会，让她们感觉到世界都塌下了。在单纯的年龄里，她们呢其实和正常的孩子们是一样的生活，学习，正式这种不平等的眼光，小文只能不断的渴求着成长，渴望着用化妆品和衣服等等来装饰着自己，让自己变得更加成熟，让自己能够战胜内心中的黑暗和恐惧。</p>
<p>看到电影里的让人更加痛心疾首的不是女孩子们的遭遇，而是男人的懦弱，自私自利，有各种形态的人利用女性，殴打女性。无可厚非，虽然现在各种强调男女平等，总是有各种调查显示好像女性地位还要高些，但是现实中，女性在当今社会上地位还是很不平等。就拿经常被提起的，离婚的女性，其实 承受了很大的社会压力，就像小文妈的样子，同样不被社会所接纳，像是融合了所有离婚女人的不美好。因为社会上的一部分人，甚至说是那种传统思想吧，总是把一个女人和她的身体联系在一起，理解成，一个女人的价值就是她的身体。</p>
<p>真的很可笑了，现在越来越发掘是男性的问题了，女人不应该承受这些，老一辈的三从四德，至今可能还在影响着我们这一辈的人。当然社会总是光明的，律师，让她们看到了希望，最终逃过一劫的刘会长受到了法律的制裁。提升女性的权力和安全，在整个社会中接受，理性对待她们。我想，这起码也是社会文明的一大进步。</p>
<blockquote>
<p>“现在大家特别喜欢把脏和女孩子放在一起说，但这是为什么？在我眼里没有女孩是脏的。”</p>
</blockquote>
<p>最后，穿着白裙子的小米，骑着电动车，未来将是一个美好的故事。</p>
<p>虽然世俗的偏见却让她们举步维艰，可是那又如何，快乐最重要，活出你们的态度。</p>
<p>美好的事情，需要所有的人努力才能改变。这部电影将会是个开始，因为它发出的声音，重新激发了人们的认知。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了嘉年华，这次没去电影院，主要是周末一直有事情，是通过网上非正规渠道看的，网址就不暴露了，私聊也不给。&lt;/p&gt;
&lt;p&gt;感觉今年也贡献了好多张电影票了，实在是现在电影看得爆米花形式的，我只想去上厕所……&lt;/p&gt;
&lt;p&gt;这个电影还是没打算去电影院看，一个人去看电影好无聊呀；它是一个以女性的口吻来贯穿的。通过这个“幼女性侵”去讲述这个当前社会下这类人的生活状况。给人很大的震撼。&lt;/p&gt;
    
    </summary>
    
      <category term="随随便便" scheme="http://blog.wuwii.com/categories/%E9%9A%8F%E9%9A%8F%E4%BE%BF%E4%BE%BF/"/>
    
    
      <category term="电影" scheme="http://blog.wuwii.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>以后的生活</title>
    <link href="http://blog.wuwii.com/later-after.html"/>
    <id>http://blog.wuwii.com/later-after.html</id>
    <published>2017-11-27T14:08:03.000Z</published>
    <updated>2017-11-28T00:57:23.695Z</updated>
    
    <content type="html"><![CDATA[<p>晚上和室友吃完饭后，大晚上出门散散步，走在平时居住的小区的路上。看着为数不多的居民楼还亮着灯光，左手和右手边的房子样式差异很大，左手边是风格别异的别墅区，门前院子还亮着灯，细眼望去，里面种着各样的植物，有花草，还有蔬菜，有的院子里停着车，和急得慌的狗，想出来咬我，等下辈子吧。</p>
<p>其实，小区寂静的寂寞，只是冬天的夜晚来的太早了，人们都早早的上床睡觉了吧。</p>
<p>想到这里，也许，未来可能在这里住一辈子是什么样子的。我大概也会在这么一个小区里有一间自己的房子，会和一个人相爱，结婚，生活在这里，如果好的话，父母也可以接过来一起住，还可能养一只猫。我会把一切布置成喜欢的样子，摆上喜欢的物品，把房间打扫得干干净净、舒舒服服的。晚饭后，一家人，在小区里散散步，走出小区外，没有灯光的地方，来到漆黑的地方，一起仰望夜空中的繁星和月亮；回到家还能逗弄猫咪；有一天还会有孩子，整天调皮的打滚，一家人很开心幸福的生活在一起，在那座房子里。这样大概就是一辈子。</p>
<p>毕业已经有半年久了，其实自己还是很迷惑，想要什么样的生活，未来将在何处。</p>
<p>安静极了，出了汽车发动机的轰鸣声和狗叫声，已经没有半点声音。上楼，准备洗洗睡吧，突然发现今晚的月光其实很不错的，只是武汉现在晚上的环境不是很好，星星都看不到了，其实今晚的月光很亮的，看了下，今天农历初十，这么长时间，没认真看过天空中的月亮了，突然感觉到风有点暖。</p>
<p>在夜晚的舒适的空气中，心里渐渐平下来，想起来，如果这样度过一生，我会有些后悔的。舒适平淡的一生，一眼就能望穿的一生，还远远不能成为我活下去的理由，我还有很多地方没去过，很多事情没做。</p>
<p>将来肯定在我想做的事情，去想去的地方，不该为了贪图舒适浪费自己的人生。到时，未来终究是什么样子，究竟要做什么，怎么做，能否做成，都还没法预见。但尽力去做了，我就不会后悔。</p>
<p>路漫漫，其修远兮；吾将上下而求索。</p>
<p>抬头再望一望天空中的月亮。可以看到它笑得如此的皎洁。</p>
<p><img src="http://image.wuwii.com/later-after.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;晚上和室友吃完饭后，大晚上出门散散步，走在平时居住的小区的路上。看着为数不多的居民楼还亮着灯光，左手和右手边的房子样式差异很大，左手边是风格别异的别墅区，门前院子还亮着灯，细眼望去，里面种着各样的植物，有花草，还有蔬菜，有的院子里停着车，和急得慌的狗，想出来咬我，等下辈子吧
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>集成algolia搜索</title>
    <link href="http://blog.wuwii.com/algolia.html"/>
    <id>http://blog.wuwii.com/algolia.html</id>
    <published>2017-11-26T15:08:03.000Z</published>
    <updated>2017-11-27T00:50:14.223Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用第三方algolia搜索服务"><a href="#使用第三方algolia搜索服务" class="headerlink" title="使用第三方algolia搜索服务"></a>使用第三方algolia搜索服务</h4><p>Local Search一直都是Loading状态，太影响体验了，只好换个搜索，可以选择algolia和Swiftype，两者都是收费的，但是可以使用免费版本，可能搜索的准确性降低，提交的网页有上限。</p>
<p><strong>下面弄下algolia搜索服务步骤</strong></p>
<p>首先说下我的next主题是5.1.1版本，低于5.1.0不支持。</p>
<a id="more"></a>
<h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><p>前往<a rel="external nofollow" target="_blank" href="http://weibo.com/ttarticle/p/show?id=2309404145816167164260">algolia官网</a>进行注册，注册一个新账户。 可以使用 GitHub 或者 Google 账户直接登录，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。注册完成后，创建一个新的 Index，这个 Index，取一个名字， 将在后面使用。</p>
<p><img src="http://theme-next.iissnan.com/uploads/algolia/algolia-step-2.png" alt="image"></p>
<h5 id="本地安装-Hexo-Algolia-扩展"><a href="#本地安装-Hexo-Algolia-扩展" class="headerlink" title="本地安装 Hexo Algolia 扩展"></a>本地安装 Hexo Algolia 扩展</h5><p>在站点根目录执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save hexo-algolia</div></pre></td></tr></table></figure></p>
<p>这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。</p>
<h5 id="获取key"><a href="#获取key" class="headerlink" title="获取key"></a>获取key</h5><p>在 Algolia 服务站点上找到需要使用的一些配置的值，包括 ApplicationID、Search API Key、 Admin API Key。注意，Admin API Key 需要保密保存。</p>
<p><img src="http://theme-next.iissnan.com/uploads/algolia/algolia-step-3.png" alt="image"></p>
<p>编辑 <code>站点配置文件</code>，新增以下配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">algolia:</div><div class="line">  applicationID: 'applicationID'</div><div class="line">  apiKey: 'apiKey'</div><div class="line">  adminApiKey: 'adminApiKey'</div><div class="line">  indexName: 'indexName'</div><div class="line">  chunkSize: 5000</div></pre></td></tr></table></figure>
<p>替换除了 chunkSize 以外的其他字段为在 Algolia 获取到的值。</p>
<h5 id="更新Index"><a href="#更新Index" class="headerlink" title="更新Index"></a>更新Index</h5><p>在站点根目录下执行 hexo algolia 来更新 Index：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo algolia</div></pre></td></tr></table></figure></p>
<p>中间更新Index的时候出现了点小岔子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo algolia</div><div class="line">ERROR [Algolia] Please set an `HEXO_ALGOLIA_INDEXING_KEY` environment variable to enable content indexing.</div><div class="line">ERROR &gt;&gt; Read https://npmjs.com/hexo-algolia#api-key for more informations.</div></pre></td></tr></table></figure></p>
<p>这个时候不要去百度，直接去它给的网页中，就可以找到解决办法。</p>
<blockquote>
<p>A separate <em>API Key</em> must be provided as an <strong>environment variable</strong> named <code>HEXO_ALGOLIA_INDEXING_KEY</code>. Create it with <strong>these limited write access</strong> permissions: <code>Add records</code>, <code>Delete records</code>, <code>List indices</code>, <code>Delete index</code>.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> HEXO_ALGOLIA_INDEXING_KEY=…</div></pre></td></tr></table></figure></p>
</blockquote>
<p>为了安全，需要将<strong>API Key</strong>重新设置上面给的那几个权限，并且在本地设置环境变量。</p>
<p>重新更新Index，可以完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INFO  [Algolia] Identified 114 pages and posts to index.</div><div class="line">INFO  [Algolia] Indexing chunk 1 of 3 (50 items each)</div><div class="line">INFO  [Algolia] Indexing chunk 2 of 3 (50 items each)</div><div class="line">INFO  [Algolia] Indexing chunk 3 of 3 (50 items each)</div><div class="line">INFO  [Algolia] Indexing done.</div></pre></td></tr></table></figure>
<p>如上面提示，表示成功。已经提交了114篇文章或网页到index了。</p>
<h5 id="集成到主题中"><a href="#集成到主题中" class="headerlink" title="集成到主题中"></a>集成到主题中</h5><p>更改主题配置文件，找到 Algolia Search 配置部分：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Algolia Search</div><div class="line">algolia_search:</div><div class="line">  enable: false</div><div class="line">  hits:</div><div class="line">    per_page: 10</div><div class="line">  labels:</div><div class="line">    input_placeholder: Search for Posts</div><div class="line">    hits_empty: "We didn't find any results for the search: $&#123;query&#125;"</div><div class="line">    hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"</div></pre></td></tr></table></figure></p>
<p>将 <code>enable</code> 改为 <code>true</code> 即可，根据需要你可以调整 labels 中的文本。</p>
<h5 id="重新发布"><a href="#重新发布" class="headerlink" title="重新发布"></a>重新发布</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo g -d</div></pre></td></tr></table></figure>
<p>查看效果：</p>
<p><img src="http://image.wuwii.com/next-as-search.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用第三方algolia搜索服务&quot;&gt;&lt;a href=&quot;#使用第三方algolia搜索服务&quot; class=&quot;headerlink&quot; title=&quot;使用第三方algolia搜索服务&quot;&gt;&lt;/a&gt;使用第三方algolia搜索服务&lt;/h4&gt;&lt;p&gt;Local Search一直都是Loading状态，太影响体验了，只好换个搜索，可以选择algolia和Swiftype，两者都是收费的，但是可以使用免费版本，可能搜索的准确性降低，提交的网页有上限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面弄下algolia搜索服务步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先说下我的next主题是5.1.1版本，低于5.1.0不支持。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://blog.wuwii.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>并发容器CopyOnWriteArrayList</title>
    <link href="http://blog.wuwii.com/java-copyonwrite.html"/>
    <id>http://blog.wuwii.com/java-copyonwrite.html</id>
    <published>2017-11-26T13:08:03.000Z</published>
    <updated>2017-12-04T00:27:53.596Z</updated>
    
    <content type="html"><![CDATA[<p>Copy-On-Write简称COW，是一种用于程序设计中的<code>优化策略</code>。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<h3 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<a id="more"></a>
<h3 id="CopyOnWriteArrayList如何做到线程安全的"><a href="#CopyOnWriteArrayList如何做到线程安全的" class="headerlink" title="CopyOnWriteArrayList如何做到线程安全的"></a>CopyOnWriteArrayList如何做到线程安全的</h3><p>CopyOnWriteArrayList使用了一种叫<code>写时复制</code>的方法，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">//1、先加锁</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Object[] elements = getArray();</div><div class="line">        <span class="keyword">int</span> len = elements.length;</div><div class="line">        <span class="comment">//2、拷贝数组</span></div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</div><div class="line">        <span class="comment">//3、将元素加入到新数组中</span></div><div class="line">        newElements[len] = e;</div><div class="line">        <span class="comment">//4、将array引用指向到新数组</span></div><div class="line">        setArray(newElements);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">//5、解锁</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出来CopyOnWriteArrayList的整个add操作都是在锁的保护下进行的。</p>
<p>当有新元素加入的时候，如下图，创建新数组，并往新数组中加入一个新元素,这个时候，array这个引用仍然是指向原数组的。</p>
<p><img src="http://img.blog.csdn.net/20170117145928110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGluc29uZ2JpbjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br><em>图片来自水印</em></p>
<p>当元素在新数组添加成功后，将array这个引用指向新数组。</p>
<p><img src="http://img.blog.csdn.net/20170117150336836?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGluc29uZ2JpbjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br><em>图片来自水印</em></p>
<p>读取操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> get(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>但是它的读操作并没有同步，因此读取它的数据的时候不一定是最新的数据。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>注意内存的消耗，每次进行写入操作的时候，都会复制一个副本，如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；</li>
<li>CopyOnWriteArrayList 合适读多写少的场景，不过这类慎用<br>因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li>
<li>设计思想：并发时候，可以开辟新的地址，来解决并发问题。</li>
</ol>
<p><strong>参考文章：</strong></p>
<ul>
<li><a rel="external nofollow" target="_blank" href="http://blog.csdn.net/linsongbin1/article/details/54581787">线程安全的CopyOnWriteArrayList介绍</a></li>
<li><a rel="external nofollow" target="_blank" href="https://www.cnblogs.com/dolphin0520/p/3938914.html">Java并发编程：并发容器之CopyOnWriteArrayList（转载）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Copy-On-Write简称COW，是一种用于程序设计中的&lt;code&gt;优化策略&lt;/code&gt;。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。&lt;/p&gt;
&lt;h3 id=&quot;什么是CopyOnWrite容器&quot;&gt;&lt;a href=&quot;#什么是CopyOnWrite容器&quot; class=&quot;headerlink&quot; title=&quot;什么是CopyOnWrite容器&quot;&gt;&lt;/a&gt;什么是CopyOnWrite容器&lt;/h3&gt;&lt;p&gt;CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
      <category term="并发编程" scheme="http://blog.wuwii.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>20171125</title>
    <link href="http://blog.wuwii.com/frightened.html"/>
    <id>http://blog.wuwii.com/frightened.html</id>
    <published>2017-11-25T15:08:03.000Z</published>
    <updated>2017-11-27T00:50:14.226Z</updated>
    
    <content type="html"><![CDATA[<p>不经意间，人开始善感起来了。</p>
<p>是人活了这么多年，还是这么怂吗？</p>
<p>不曾想过，每次做事都这么犹豫。</p>
<p>可能就是在这样的面前，才敢放低姿态。</p>
<p>不管什么事情，努力才是对自己的结果。</p>
<blockquote>
<p>世界上最好的安慰并不是告诉对方“一切都会好起来的”，而是苦着脸说“哭个屁，你看，我比你还惨”。</p>
<p>嘿，你好吗？<br>我很好。 </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不经意间，人开始善感起来了。&lt;/p&gt;
&lt;p&gt;是人活了这么多年，还是这么怂吗？&lt;/p&gt;
&lt;p&gt;不曾想过，每次做事都这么犹豫。&lt;/p&gt;
&lt;p&gt;可能就是在这样的面前，才敢放低姿态。&lt;/p&gt;
&lt;p&gt;不管什么事情，努力才是对自己的结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;世界上
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程中ThreadLocal</title>
    <link href="http://blog.wuwii.com/java-threadlocal.html"/>
    <id>http://blog.wuwii.com/java-threadlocal.html</id>
    <published>2017-11-24T17:08:03.000Z</published>
    <updated>2017-11-27T00:50:14.252Z</updated>
    
    <content type="html"><![CDATA[<p>没写完，头痛，到凌晨了，先占个坑，先睡个觉，明天再补。</p>
<hr>
<p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p>但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。<br><a id="more"></a></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="拥有方法"><a href="#拥有方法" class="headerlink" title="拥有方法"></a>拥有方法</h4><p><img src="http://image.wuwii.com/ThreadLocal1.png" alt="image"><br>下面看下几个怎么设计实现ThreadLocal的方法：</p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Returns the value in the current thread's copy of this</span></div><div class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></div><div class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></div><div class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread's value of this thread-local</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                T result = (T)e.value;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>获取当前线程；</li>
<li>然后通过getMap 获取Map；</li>
<li>获取到Map的键值对；</li>
<li>传入<code>this</code> 当前ThreadLocal获取当前的键值对；</li>
<li>根据获取到的entry 返回值，为null 的话调用<code>setInitialValue</code>方法；<h4 id="getMap"><a href="#getMap" class="headerlink" title="getMap"></a>getMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Get the map associated with a ThreadLocal. Overridden in</span></div><div class="line"><span class="comment">     * InheritableThreadLocal.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span>  t the current thread</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> the map</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>返回线程中的threadLocals变量，继续看threadLocals的实现；</p>
<h4 id="threadLocals"><a href="#threadLocals" class="headerlink" title="threadLocals"></a>threadLocals</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line"><span class="comment">     * by the ThreadLocal class. */</span></div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>它是ThreadLocal中的静态内部类ThreadLocalMap：</p>
<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><h5 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">            Object value;</div><div class="line"></div><div class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">                <span class="keyword">super</span>(k);</div><div class="line">                value = v;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p>
<h4 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue"></a>setInitialValue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Variant of set() to establish initialValue. Used instead</span></div><div class="line"><span class="comment">     * of set() in case user has overridden the set() method.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> the initial value</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        T value = initialValue();</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现;</p>
<h4 id="createMap"><a href="#createMap" class="headerlink" title="createMap"></a>createMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></div><div class="line"><span class="comment">     * InheritableThreadLocal.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这样为当前线程创建副本变量就完毕了。</p>
<h4 id="怎么创建副本变量"><a href="#怎么创建副本变量" class="headerlink" title="怎么创建副本变量"></a>怎么创建副本变量</h4><p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>各种连接池获取连接（如，数据库连接，redis连接）；</li>
<li>session管理。</li>
</ol>
<h3 id="学习代码"><a href="#学习代码" class="headerlink" title="学习代码"></a>学习代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.wuwii.test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/24 20:32&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 声明一个ThreadLocal变量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; local1 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 为ThreadLocal赋值</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        local1.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</div><div class="line">         Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">             <span class="comment">/*</span></div><div class="line"><span class="comment">              * 每次调用get方法前，必须要set，不然会抛出NPE</span></div><div class="line"><span class="comment">              */</span></div><div class="line">            setValue();</div><div class="line">            System.out.printf(<span class="string">"线程一的localValue为: %s%n"</span>, local1.get());</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="comment">//先给线程二的threadLocal赋值，然后运行线程一，最后打印线程二的threadLocal</span></div><div class="line">            setValue();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">/*</span></div><div class="line"><span class="comment">                 * 在线程二中添加运行线程一，证明了每个线程保存的ThreadLocal的副本变量是不同的</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                thread1.start();</div><div class="line">                thread1.join();</div><div class="line">                <span class="comment">// 运行完线程一，再输出线程二</span></div><div class="line">                System.out.printf(<span class="string">"线程二的localValue为: %s%n"</span>, local1.get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">线程一的localValue为: Thread-0</div><div class="line">线程二的localValue为: Thread-1</div></pre></td></tr></table></figure></p>
<p>可以看出，线程二并没有被影响。</p>
<p><strong>参考博客：<a rel="external nofollow" target="_blank" href="http://www.cnblogs.com/dolphin0520/p/3920407.html">Java并发编程：深入剖析ThreadLocal</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没写完，头痛，到凌晨了，先占个坑，先睡个觉，明天再补。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。&lt;/p&gt;
&lt;p&gt;但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
      <category term="并发编程" scheme="http://blog.wuwii.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用一生的时光去守护你</title>
    <link href="http://blog.wuwii.com/a-living-time.html"/>
    <id>http://blog.wuwii.com/a-living-time.html</id>
    <published>2017-11-23T14:08:03.000Z</published>
    <updated>2017-11-24T09:22:07.481Z</updated>
    
    <content type="html"><![CDATA[<p>今天听电台上逛到了这篇文章，首先想到的应该是爸妈那一代人，是我们比较熟悉的，那缝纫机，我家里现在还能用了；我小时候学习骑车的时候，用的就是当初爸妈结婚的时候自行车；还有当时的小彩电，被我拿来打游戏机了……现在想起来，惭愧的很，没能好好珍惜，那是属于父母的美好记忆的一部分。当然都过去好久了，我的记忆力还是不错的，虽然大多数东西已经不存在了，但是能一直存在我的记忆里，我想爸妈也是一直记得的，而且现在家庭幸福，就足够了。</p>
<p>文章来自网上，百度标题就有，读起来可以细细品尝，喝杯水，别是一番风味。</p>
<p>记录到博客（图片都是偷的……<br><a id="more"></a></p>
<hr>
<p><img src="http://p3.pstatp.com/large/6d100072fd427166ee8" alt="image"></p>
<p><strong>五六十年代的爱情，没有绚烂的色彩，却有着耐人寻味的真情。</strong></p>
<p><img src="http://p9.pstatp.com/large/71e00034b657f43e581" alt="image"></p>
<p><strong>那个时候，总有做不完的农活，苦中作乐就是甜蜜的爱情。</strong></p>
<p><img src="http://p3.pstatp.com/large/6d100072fd55d030dc9" alt="image"></p>
<p><strong>在当时，为心爱的女人戴上一朵红花，是爱情的见证，更是一种矢志不渝的承诺。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/5ce0edf0e5cb48349c356321d86143f4_th.jpg" alt="image"></p>
<p><strong>结婚前不需贵重的礼品，一支钢笔就是一个深刻的纪念。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/00208259a24e47e3ac983be8d1b478b3_th.jpg" alt="image"></p>
<p><strong>那时候结婚，还需要组织上开个介绍信。接过结婚证书的时候，开心到说不出话来。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/255bedb9b6fa44f1a456851c89e3cf34_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/46d488275a0e4b5ea018a421e609788c_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/0b1bd30a0f624ffab5df7bd8c338ac6c_th.jpg" alt="image"></p>
<p><strong>那时候的爱情，总是有众人的见证。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/9c81860520044b9aaf0cae637d370a13_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/16c9b7f033c3440191d7405f39384f44_th.jpg" alt="image"></p>
<p><strong>到了七十年代，爱情故事也随着时代而发生改变。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/1077aaf711ac41ecb555bc662085cd42_th.jpg" alt="image"></p>
<p><strong>在那个特殊的年代，爱情是被禁止的羞涩。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/c1ebcfd1f6dd4e9ba01d934b74b467a3_th.jpg" alt="image"></p>
<p><strong>“恋爱”“结婚”，是资产阶级思想的自由化产物，“男女关系”是绝对要划清界限的个人守则。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/527e2229d3f54a9d9b9402ede6a842ec_th.jpg" alt="image"></p>
<p><strong>那个时代的人们单纯，生怕别人误会自己有不正当男女关系，生怕别人误会老家来的表哥是自己的汉子。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/a0ea7bc642844de3b6b91408136a2bc0_th.jpg" alt="image"></p>
<p><strong>那时候，连牵个小手都得偷偷摸摸的，一根小小的竹竿连接着他们青涩的爱情。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/b2eb2ef274454388957f69b23f3106db_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/061b45c9946b43708f3f8ceaa25ecc5d_th.jpg" alt="image"></p>
<p><strong>那时候的爱情，也是政治。身穿军装、手捧毛主席语录照相，是那个年代最独特的记忆。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/88071ca9faa34ebdb452aa21b868974e_th.jpg" alt="image"></p>
<p><strong>80年代，有了一种独特的恋爱方式，叫做联谊。说说笑笑，感情自然而然地发生。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/8e1e1034d8494186b87f7c9197deb69f_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/c4cdf0604fc64f21a78403396b53bc4a_th.jpg" alt="image"></p>
<p><strong>在没有电话、电脑的年代，写信寄照片是唯一联系情感的方式。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/54c2769ec19947e3b9a4ef22abd85d82_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/99aefc436e9647ba9a98634a0ba44d53_th.jpg" alt="image"></p>
<p><strong>那时候的约会很简单，坐趟公交车到郊外走走，到湖边划划小船。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/b5138d92ebe849a1b74009a3e711f0c8_th.jpg" alt="image"></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/393d7c957d014d5e90474250d7ebe211_th.jpg" alt="image"></p>
<p><strong>只要两个人在一起，在公园的长椅上坐上一个下午也不会觉得无聊。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/332b5900b72d4fc1a1bf3635a9ee2631_th.jpg" alt="image"></p>
<p><strong>骑着自行车，载着心爱的那个她，真希望时光就停留在这一刻。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/101a7ea965a24e52b398902c74115828_th.jpg" alt="image"></p>
<p><strong>带上礼物，和心爱的人穿戴整齐，一起回家里看看爸妈。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/619406bd3a99447abe2b8a97683272e3_th.jpg" alt="image"></p>
<p><strong>一台缝纫机，一辆自行车，一台收音机，加上母亲准备的花棉被，就是全部的嫁妆。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/3066796109054dceb217c06419be6b37_th.jpg" alt="image"></p>
<p><strong>那个年代，爱情有着纯粹的颜色，神圣不容亵渎。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/94a5274509284b209227b242f4088d06_th.jpg" alt="image"></p>
<p><strong>那个年代，车马很慢，书信很远，一生只够爱一人。</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/a1120031cd624a76a3887f1b26bdb7eb_th.jpg" alt="image"></p>
<p><strong>30年前的我爱你，不是嘴上说说，</strong></p>
<p><strong>而是用一生的时光去守护你！</strong></p>
<p><img src="http://img.mp.itc.cn/upload/20160528/bf016bb8559c4e4aae0a8e101ba191d3_th.jpg" alt="image"></p>
<hr>
<blockquote>
<p>“两姓联姻，一堂缔约，良缘永结，匹配同称。看此日桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。谨以白头之约，书向鸿笺，好将红叶之盟，载明鸳谱。此证。” </p>
<p>张爱玲说过：“于千万人之中遇见你所要遇见的人,于千万年之中,时间的无涯的荒野里,没有早一步,也没有晚一步,刚巧赶上了,没有别的话可说,唯有轻轻地问一声:“原来你也在这里 ”</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天听电台上逛到了这篇文章，首先想到的应该是爸妈那一代人，是我们比较熟悉的，那缝纫机，我家里现在还能用了；我小时候学习骑车的时候，用的就是当初爸妈结婚的时候自行车；还有当时的小彩电，被我拿来打游戏机了……现在想起来，惭愧的很，没能好好珍惜，那是属于父母的美好记忆的一部分。当然都过去好久了，我的记忆力还是不错的，虽然大多数东西已经不存在了，但是能一直存在我的记忆里，我想爸妈也是一直记得的，而且现在家庭幸福，就足够了。&lt;/p&gt;
&lt;p&gt;文章来自网上，百度标题就有，读起来可以细细品尝，喝杯水，别是一番风味。&lt;/p&gt;
&lt;p&gt;记录到博客（图片都是偷的……&lt;br&gt;
    
    </summary>
    
      <category term="分享" scheme="http://blog.wuwii.com/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="故事" scheme="http://blog.wuwii.com/tags/%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Easyui异步ComboTree加载到指定子节点展开</title>
    <link href="http://blog.wuwii.com/easyui-combotree.html"/>
    <id>http://blog.wuwii.com/easyui-combotree.html</id>
    <published>2017-11-22T15:08:03.000Z</published>
    <updated>2017-11-22T14:41:00.189Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Easyui异步ComboTree加载到指定子节点展开</strong>，其实以为这个功能会很简单，做起来出了一些问题，现在做完了，也还是存在一些隐患，记录，等找到最好的解决办法：</p>
<a id="more"></a>
<h4 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h4><p>业务其实是一个很普通的省市县的级联查询，但是，我们不是那个一级一级的方式选择的，是直接加载一棵树，在到树下一级一级的选到想要的位置。</p>
<p>主要就是加载异步树，还有就是去加载到当前指定的子节点上，并且打开每一级的父节点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;测试玩&lt;<span class="regexp">/title&gt;</span></div><div class="line"><span class="regexp">    &lt;link rel="stylesheet" href="../</span>../theme/<span class="keyword">default</span>/easyui.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;link rel="</span>stylesheet<span class="string">" type="</span>text/css<span class="string">" href="</span>../../theme/icon.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;link rel="</span>stylesheet<span class="string">" type="</span>text/css<span class="string">" href="</span>../../css/app.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;link rel="</span>stylesheet<span class="string">" type="</span>text/css<span class="string">" href="</span>../../css/main.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;link rel="</span>stylesheet<span class="string">" type="</span>text/css<span class="string">" href="</span>../../css/icon.css<span class="string">"/&gt;</span></div><div class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">" src="</span>../../js/jquery.min.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">" src="</span>../../js/jquery.easyui.min.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">" src="</span>../../js/easyui-lang-zh_CN.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">&lt;/head&gt;</span></div><div class="line"><span class="string">&lt;body&gt;</span></div><div class="line"><span class="string">&lt;input id="</span>tree<span class="string">"/&gt;</span></div><div class="line"><span class="string">&lt;!--测试使用打开到指定的子节点--&gt;</span></div><div class="line"><span class="string">&lt;a id="</span>expand<span class="string">"&gt;指定打开&lt;/a&gt;</span></div><div class="line"><span class="string">&lt;script type="</span>text/javascript<span class="string">"&gt;</span></div><div class="line"><span class="string">    /**</span></div><div class="line"><span class="string">     * 后台服务url自己修改成配置文件的</span></div><div class="line"><span class="string">     */</span></div><div class="line"><span class="string">    var baseUrl = "</span>http:<span class="comment">//192.168.19.207:8081/devframe-server/";</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 记录级联信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">var</span> selectNode = &#123;</div><div class="line">        province: <span class="literal">null</span>,</div><div class="line">        city: <span class="literal">null</span>,</div><div class="line">        county: <span class="literal">null</span>,</div><div class="line">        town: <span class="literal">null</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据type判断级联</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">var</span> nodeType = &#123;</div><div class="line">        province: <span class="string">'province'</span>,</div><div class="line">        city: <span class="string">'city'</span>,</div><div class="line">        county: <span class="string">'county'</span>,</div><div class="line">        town: <span class="string">'town'</span></div><div class="line">    &#125;</div><div class="line">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        initComboTree();</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 初始化ComboTree</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initComboTree</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//第一次加载成功需要选中高亮第一个节点</span></div><div class="line">        <span class="keyword">var</span> isHighlight = <span class="literal">true</span>;</div><div class="line">        $(<span class="string">"#tree"</span>).combotree(&#123;</div><div class="line">            method: <span class="string">"post"</span>,</div><div class="line">            url: baseUrl + <span class="string">'dictionary/asyncdata/canton'</span>,</div><div class="line">            panelWidth: <span class="string">'170'</span>,</div><div class="line">            onClick: <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">                getNodeMessage(node);</div><div class="line">            &#125;,</div><div class="line">            onBeforeExpand: <span class="function"><span class="keyword">function</span> (<span class="params">node, param</span>) </span>&#123;</div><div class="line">                $(<span class="keyword">this</span>).tree(<span class="string">'options'</span>).url = baseUrl + <span class="string">'dictionary/asyncdata/canton?id='</span> + node.id;</div><div class="line">            &#125;,</div><div class="line">            onLoadSuccess: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (!isHighlight) <span class="keyword">return</span>;</div><div class="line">                $(<span class="string">"#tree li:eq(0)"</span>).find(<span class="string">"div"</span>).addClass(<span class="string">"tree-node-selected"</span>);</div><div class="line">                <span class="keyword">var</span> n = $(<span class="keyword">this</span>).tree(<span class="string">"getSelected"</span>);</div><div class="line">                <span class="keyword">if</span> (n != <span class="literal">null</span>) $(<span class="keyword">this</span>).tree(<span class="string">"select"</span>, n.target);</div><div class="line">                isHighlight = <span class="literal">false</span>;</div><div class="line">            &#125;,</div><div class="line">            loadFilter: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">                data = data.data;</div><div class="line">                <span class="comment">//不要问为什么有这么一步，因为懒，不想改服务</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="string">'data'</span> <span class="keyword">in</span> data[i]) &#123;</div><div class="line">                        data[i].text = data[i].data;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> data;</div><div class="line">            &#125;,</div><div class="line">            formatter: <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (!node.children || node.children.length == <span class="number">0</span>) <span class="keyword">return</span> node.text;</div><div class="line">                <span class="keyword">return</span> node.text + <span class="string">'&lt;span style="color:blue"&gt;('</span> + node.children.length + <span class="string">')&lt;/span&gt;'</span>;</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">//屏蔽浏览器默认的右键事件，改为和左键点击事件一样的了</span></div><div class="line">            onContextMenu: <span class="function"><span class="keyword">function</span> (<span class="params">e, node</span>) </span>&#123;</div><div class="line">                e.preventDefault();</div><div class="line">                $(<span class="keyword">this</span>).tree(<span class="string">'select'</span>, node.target);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 编辑状态中的树，需要展开到指定节点</span></div><div class="line"><span class="comment">     * @param id 需要展开的Id</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">editComboTree</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            type: <span class="string">'post'</span>,</div><div class="line">            url: baseUrl + <span class="string">'dictionary/expandto/'</span> + id,</div><div class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (response == <span class="literal">null</span> || response.statusCode == <span class="number">400</span>) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                $(<span class="string">"#tree"</span>).combotree(<span class="string">'loadData'</span>, response);</div><div class="line">                $(<span class="string">"#tree"</span>).combotree(<span class="string">'setValue'</span>, id);</div><div class="line">            &#125;,</div><div class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">                <span class="comment">//TODO error</span></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 点击树，获取级联的信息</span></div><div class="line"><span class="comment">     * @param node 节点</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNodeMessage</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> remark = node.type;</div><div class="line">        <span class="keyword">if</span> (remark == <span class="literal">null</span> || remark == <span class="string">""</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remark == nodeType.province) &#123;</div><div class="line">            selectNode.province = node.text;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remark == nodeType.city) &#123;</div><div class="line">            selectNode.city = node.text;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remark == nodeType.county) &#123;</div><div class="line">            selectNode.county = node.text;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remark == nodeType.town) &#123;</div><div class="line">            selectNode.town = node.text;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//查找父级节点，没有则退出</span></div><div class="line">        <span class="keyword">var</span> parent = getParentNode(node);</div><div class="line">        <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</div><div class="line">            getNodeMessage(parent)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据节点获取父节点</span></div><div class="line"><span class="comment">     * @param node 节点</span></div><div class="line"><span class="comment">     * @returns &#123;*&#125; 父节点</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getParentNode</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> tree = $(<span class="string">'#tree'</span>).combotree(<span class="string">'tree'</span>);</div><div class="line">        <span class="keyword">return</span> tree.tree(<span class="string">'getParent'</span>, node.target);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//测试的，打开到指定的子节点，点击事件</span></div><div class="line">    $(<span class="string">"#expand"</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        editComboTree(<span class="string">'431000000000'</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>body&gt;</div><div class="line">&lt;<span class="regexp">/html&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><p>服务端有点差，就不贴代码了，说下解决思路。</p>
<ul>
<li>持久层框架：JPA</li>
<li>数据库：PostgreSQL<h5 id="加载异步树的服务"><a href="#加载异步树的服务" class="headerlink" title="加载异步树的服务"></a>加载异步树的服务</h5>主要是利用了SQL，对，使用原生SQL查的。这里还有一个问题，就是easyui的ComboTree加载异步树的时候，需要判断当前查询出来的节点下面还有没有子节点，就是我们平常看到树的前面有一个尖三角符号，用来表示是否能展开。<br>ComboTree同时继承了Combo和Tree两个的特点，其实，就是把数据绑定到tree上，tree的节点（node）有一个属性是<code>state</code>，用来控制树的该节点的展开与否，它有两个值：<code>open</code>和<code>closed</code>，所以查询的时候干脆就直接的查出了这个属性，SQL有些特别：</li>
</ul>
<p>condition参数是接到WHERE后面的查询条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AtomicReference&lt;String&gt; sql = new AtomicReference&lt;&gt;(&quot;SELECT T.*,CASE WHEN T1.\&quot;COUNT\&quot;=0 OR &quot; +</div><div class="line">               &quot;T1.\&quot;COUNT\&quot; IS NULL THEN &apos;open&apos; WHEN T1.\&quot;COUNT\&quot;&gt;0 THEN &apos;closed&apos; END AS \&quot;STATE\&quot; &quot; +</div><div class="line">               &quot;FROM(SELECT * FROM \&quot;DEV_DICTIONARY\&quot; WHERE &quot; + condition.get() +</div><div class="line">               &quot; ORDER BY \&quot;PARENTID\&quot;) T LEFT JOIN (SELECT \&quot;PARENTID\&quot;, COUNT(\&quot;PARENTID\&quot;) \&quot;COUNT\&quot; FROM \&quot;DEV_DICTIONARY\&quot; &quot; +</div><div class="line">               &quot;WHERE \&quot;PARENTID\&quot; IN (SELECT \&quot;ID\&quot; FROM \&quot;DEV_DICTIONARY\&quot; WHERE &quot; + condition.get() + &quot;) &quot; +</div><div class="line">               &quot;GROUP BY \&quot;PARENTID\&quot;) T1 ON T.\&quot;ID\&quot; = T1.\&quot;PARENTID\&quot;&quot;);</div></pre></td></tr></table></figure></p>
<p>这样太难看了，最后娶一个实例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">        T.*,</div><div class="line">        <span class="keyword">CASE</span> </div><div class="line">            <span class="keyword">WHEN</span> T1.<span class="string">"COUNT"</span>=<span class="number">0</span> </div><div class="line">            <span class="keyword">OR</span> T1.<span class="string">"COUNT"</span> <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">'open'</span> </div><div class="line">            <span class="keyword">WHEN</span> T1.<span class="string">"COUNT"</span>&gt;<span class="number">0</span> <span class="keyword">THEN</span> <span class="string">'closed'</span> </div><div class="line">        <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">"STATE"</span> </div><div class="line">    <span class="keyword">FROM</span></div><div class="line">        (<span class="keyword">SELECT</span></div><div class="line">            * </div><div class="line">        <span class="keyword">FROM</span></div><div class="line">            <span class="string">"DEV_DICTIONARY"</span> </div><div class="line">        <span class="keyword">WHERE</span></div><div class="line">            <span class="string">"TYPE"</span>=<span class="string">'canton'</span> </div><div class="line">            <span class="keyword">AND</span> <span class="string">"PARENTID"</span> <span class="keyword">is</span> <span class="literal">null</span> </div><div class="line">            </div><div class="line">                    <span class="keyword">ORDER</span> <span class="keyword">BY</span></div><div class="line">                        <span class="string">"PARENTID"</span></div><div class="line">                ) T </div><div class="line">            <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></div><div class="line">                (</div><div class="line">                    <span class="keyword">SELECT</span></div><div class="line">                        <span class="string">"PARENTID"</span>,</div><div class="line">                        <span class="keyword">COUNT</span>(<span class="string">"PARENTID"</span>) <span class="string">"COUNT"</span> </div><div class="line">                    <span class="keyword">FROM</span></div><div class="line">                        <span class="string">"DEV_DICTIONARY"</span> </div><div class="line">                    <span class="keyword">WHERE</span></div><div class="line">                        <span class="string">"PARENTID"</span> <span class="keyword">IN</span> (</div><div class="line">                            <span class="keyword">SELECT</span></div><div class="line">                                <span class="string">"ID"</span> </div><div class="line">                            <span class="keyword">FROM</span></div><div class="line">                                <span class="string">"DEV_DICTIONARY"</span> </div><div class="line">                            <span class="keyword">WHERE</span></div><div class="line">                                <span class="string">"TYPE"</span>=<span class="string">'canton'</span> </div><div class="line">                                <span class="keyword">AND</span> <span class="string">"PARENTID"</span> <span class="keyword">is</span> <span class="literal">null</span> )</div><div class="line">                            <span class="keyword">GROUP</span> <span class="keyword">BY</span></div><div class="line">                                <span class="string">"PARENTID"</span></div><div class="line">                        ) T1 </div><div class="line">                            <span class="keyword">ON</span> T.<span class="string">"ID"</span> = T1.<span class="string">"PARENTID"</span></div></pre></td></tr></table></figure></p>
<p>这样查询出来的就多了一列state，按照是否有子集，设置它是closed 还是open。</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171122215405.png" alt="image"></p>
<p>当然还需要到实体类上去映射好这个属性字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Column(name = &quot;\&quot;STATE\&quot;&quot;)</div><div class="line">private String state;</div></pre></td></tr></table></figure></p>
<h5 id="加载到指定节点"><a href="#加载到指定节点" class="headerlink" title="加载到指定节点"></a>加载到指定节点</h5><p>加载到指定节点，并展开到该节点。这个就用脑图说下思路吧。暂时我感觉我的做法不是很好，我看能不能减少复杂度，期待以后能解决，看到的朋友如果有好的解决办法，请与我联系，万分感谢。<br><img src="http://ov62kaxkk.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171122221203.png" alt="image"></p>
<p>其实我们需要找到的数据就是这样的一组数据：<br>首先找到同级的，再去找父的，父的又去找自己的同级，再去找自己的上一级。。。直到找到root节点，完毕。</p>
<p>我是分步做的，应该有更少步骤或者一条SQL完成的，下去研究，估计有点难。</p>
<h4 id="展示下结果吧"><a href="#展示下结果吧" class="headerlink" title="展示下结果吧"></a>展示下结果吧</h4><p>异步树：<br><img src="http://ov62kaxkk.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171122221612.png" alt="image"></p>
<p>展示到指定节点效果:</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171122221552.png" alt="image"></p>
<p>还要注意一点，就是请求服务使用get会好些，get比post快，但是要加上时间戳，避免去读取浏览器缓存数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Easyui异步ComboTree加载到指定子节点展开&lt;/strong&gt;，其实以为这个功能会很简单，做起来出了一些问题，现在做完了，也还是存在一些隐患，记录，等找到最好的解决办法：&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="easyui" scheme="http://blog.wuwii.com/tags/easyui/"/>
    
      <category term="Web前端" scheme="http://blog.wuwii.com/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>《小王子》读后感</title>
    <link href="http://blog.wuwii.com/princekin.html"/>
    <id>http://blog.wuwii.com/princekin.html</id>
    <published>2017-11-21T15:08:03.000Z</published>
    <updated>2017-11-28T00:57:23.726Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>从前呀，有一位小王子，他住在同自己差不多大的星球上，他想要一位朋友。</p>
</blockquote>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/timg.jpg" alt="image"></p>
<p>平时比较忙，如果说读小说的话时间太长了，还有很多专业的书没看，弄得半年都过去了《飘》都没看完，说句老实话，我是个不喜欢读书的人/。。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>然而他却放佛面对意见很严肃的事情，第二次从容迫不及待的对我说：“请为了画只羊。”</p>
</blockquote>
<p>这句话应该很经典，这也是故事中羊的由来，故事中的我从未划过羊，内心其实是很害怕的，其实看得多才知道，为什么会有羊这个片段，说到底就是年少的单纯吧，让羊去啃那个面包树；但是也有可能是追求善良吧，个人理解。</p>
<blockquote>
<p>忘记一位朋友，这真使人悲哀。并非每个人都有过一位朋友。</p>
</blockquote>
<p>这段话真是揪心啊，与朋友一起是一个很快乐的事情，但是想忘记一个人真的很痛苦吧，也许有一天，会慢慢淡忘一个人。但是在当前岁月下，好好珍惜身边的每一个爱你和你爱的人。现在，买得起充电五分钟的手机，但是通话两小时的人可不好找。</p>
<blockquote>
<p>猴面包树在长大以前也是很小的。</p>
</blockquote>
<p>小王子在知道羊吃小灌木的时候，他很开心，它们可以吃猴面包树了，但是猴面包树已经长得很大，羊可吃不了，只有在它小的时候，才能警惕它。孩子们，要当心那些猴面包树呀！<br>猴面包树是人们都不想要的东西，想放弃的东西，但是，人们是自私的，想放下，却不想放下，但是自己又不甘放下那段执念，明知结果不好，确实还是贪婪的霸占着这一片不属于你的土地，最好确是还是一步一步越陷越深。所以要在开始有这种心理的时候就要把它铲除掉，找到自己的玫瑰，将它种下，在心中发芽，这样心中才能充满美好。</p>
<blockquote>
<p>你知道，当感到十分愁闷的时候，人们都会想看太阳落山。</p>
</blockquote>
<p>小王子一天能看四十三次日出，那是多么忧郁的生活啊，也许唯一的快乐就是看日落，人总是在不知不觉中，感到愁闷，而且是非常糟糕的那种，人为什么会那么难过了。<br>可能是有一种人，就像我吧，总是喜欢把悲伤隐藏的深一点，再深一点，习惯性了都，当然各种事情都有暴露的，比如说，悲伤的时候想看日落，哈哈。说不定高兴的时候就想看日出了。</p>
<blockquote>
<p>对别人提出的要求必须是他们能够办到的。权力首先应当以理性为基础。</p>
</blockquote>
<p>小王子来到一个星球上，住的只有一个国王，他统治着一切，但是他并没有拥有一切，。虽然他拥有着至高无上的权力，但是天真地想让自己统治一切，发出不合理的命令来强人所难。<br>所以在现实社会中，首先要求别人做事的时候，一定要考虑到他人感受为前提，虽然你可能是BOSS，但是优秀员工都有随时踢开SB 老板的权力。扯远了，永远不要忘了，不能提出不合理的要求。</p>
<blockquote>
<p>虚荣心极强的人眼中，所有的人都是他们的崇拜者。</p>
</blockquote>
<p>这个怎么说了，虚荣，当今社会，每个人都可能会犯的毛病了，可能不经意间，就出现了，只不过没发现，觉得理所当然，当然只是自己觉得，哈哈。我说我长得好帅，万人迷，当然这个不是虚荣，只是小小的吹牛皮。很无聊的，不说了。</p>
<blockquote>
<p>“你为什么要喝酒？”“为了忘记。”“忘记什么？”“忘记我的惭愧。”“你惭愧什么？”“我惭愧我喝酒”……</p>
</blockquote>
<p>有时候，就是陷入自己设下的思维怪圈中，怎么才能跳出来？<br>亲爱的，面对现实的一切，不要自我麻痹。</p>
<blockquote>
<p>对我而言，假如我有一条围巾，我会用它围我的脖子，而且我可以带走它。我有一朵花，我就会摘下我的花朵，而且我可以将它带走。但你却无法摘下满天的星星啊。</p>
</blockquote>
<p>每次看到这段话的时候我都很触动。商人很富有，霸占了所有的星星，拥有一切，但是他却并没有获得他们。<br>星星是多么的耀眼，那么的迷人，但我宁愿有一条可以围在脖子上的围巾，还有一个带走的花。</p>
<blockquote>
<p>规定倒的地方没改变，这就是倒霉的地方！这颗星球一年比一年转得快，当规定却没改。</p>
</blockquote>
<p>哎，初看点灯人，觉得是个很可爱得人儿，他做着自己口中所说的讨厌的工作，却忠于职守，而且，是那种一成不变的，星球越转越快，但却口令没变，导致每一分钟都要点灯，灭灯，小王子让他改下，他却喜欢一劳永逸。<br>看到这里不又想到现实生活中，可以说一部分人的代表吧，这里说明下，我没有黑的意思，做的同一份工作很多年，但却没有一点上升的意思，但是他们真的很刻苦用心。这个大概就是忠于职守和用心不是同一个概念了，世界上没有绝对的事情，但是有肯定的事情，随着时代进步，一定能占尽先机的。</p>
<blockquote>
<p>星星发亮是为了让每一个人有一天都能找到属于自己的星星。</p>
<p>如果你爱上了某个星球的一朵花。那么，只要在夜晚仰望星空，就会觉得漫天的繁星就像一朵朵盛开的花。</p>
</blockquote>
<p>当在一个地方存在某种特殊意义的时候，不管是什么它将都是独一无二的美丽，即便漫长黑夜里，也可以通过光亮寻找到它的位置。<br>玫瑰是简单而且性格敏感的代表，看到它的故事片段，人心都觉得好暖。玫瑰消失后，这段话很感动，也许就是“心中有了想念的人，你便不觉得孤独”的含义，无牵无挂心中空空如也才最是寂寞。对于狐狸来说，也是不会寂寞的。当然也是遗憾的。你要走便走，不要回头，我不会留。</p>
<blockquote>
<p>狐狸说：“对我来说，你只是一个小男孩，就像其他成千上万个小男孩一样没有什么两样。我不需要你。你也不需要我。对你来说，我也只是一只狐狸，和其他成千上万的狐狸没有什么不同。但是，如果你驯养了我，我们就会彼此需要。对我来说，你就是我的世界里独一无二的了；我对你来说，也是你的世界里的唯一了。”<br>一旦你驯服了什么，就要对她负责，永远的负责。</p>
</blockquote>
<p>狐狸告诉了让小王子懂得了生活的本质和爱情的真谛。“一个人被驯服,是冒着流泪的危险的”，“只有用心才能看得清。实质性的东西，用眼睛是看不见的。”<br>用心去看才看得清楚，小王子知道需要珍惜他的玫瑰；爱就是责任。</p>
<p>总之故事的结尾是伤心的。从头到尾是一个以爱情的伤痛为背景的线索，以一份纯真的爱情，爱得真切，深入骨髓得疼痛结束。</p>
<p>爱是一种责任，爱也是一种短暂易逝的美好。用心去爱你身边的每一个人，爱可以是亲情、友情……别整天就知道爱情才是爱，每一个真切对你好的人，不要让他们攒满失望离开，毕竟一生中遇到这么可爱的人真的不多，走一个少一个。</p>
<blockquote>
<p>Growing up is not the problem.Forgetting is.</p>
</blockquote>
<hr>
<p>一切仅代表个人观点哈，勿喷</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从前呀，有一位小王子，他住在同自己差不多大的星球上，他想要一位朋友。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ov62kaxkk.bkt.clouddn.com/timg.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;平时比较忙，如果说读小说的话时间太长了，还有很多专业的书没看，弄得半年都过去了《飘》都没看完，说句老实话，我是个不喜欢读书的人/。。&lt;/p&gt;
    
    </summary>
    
      <category term="随随便便" scheme="http://blog.wuwii.com/categories/%E9%9A%8F%E9%9A%8F%E4%BE%BF%E4%BE%BF/"/>
    
    
      <category term="小王子" scheme="http://blog.wuwii.com/tags/%E5%B0%8F%E7%8E%8B%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>我的蛋碎了一个</title>
    <link href="http://blog.wuwii.com/20171120.html"/>
    <id>http://blog.wuwii.com/20171120.html</id>
    <published>2017-11-21T14:08:03.000Z</published>
    <updated>2017-11-21T13:29:26.348Z</updated>
    
    <content type="html"><![CDATA[<p>真的。。</p>
<a id="more"></a>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/IMG_20171120_203908.jpg" alt="image"></p>
<p>看到这个蛋，随口喊出那句话，被自己蠢哭了。</p>
<p>支付宝刮了一张卡，感觉到马云爸爸深深的恶意。</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/Screenshot.png" alt="image"></p>
<p>用穷逼会员咋的，</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/u=3069228711,3931262156&amp;fm=27&amp;gp=0.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的。。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>使用Redis完成分布式锁</title>
    <link href="http://blog.wuwii.com/redis-lock.html"/>
    <id>http://blog.wuwii.com/redis-lock.html</id>
    <published>2017-11-20T14:08:03.000Z</published>
    <updated>2017-11-27T02:42:53.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><blockquote>
<p>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>
</blockquote>
<p>为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。</p>
<h4 id="使用Redis实现锁的原因"><a href="#使用Redis实现锁的原因" class="headerlink" title="使用Redis实现锁的原因"></a>使用Redis实现锁的原因</h4><ol>
<li>Redis有很高的性能；</li>
<li>Redis命令对此支持较好，实现起来比较方便。</li>
</ol>
<a id="more"></a>
<h4 id="主要利用到的命令"><a href="#主要利用到的命令" class="headerlink" title="主要利用到的命令"></a>主要利用到的命令</h4><h5 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h5><blockquote>
<p>SETNX key val<br>当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。</p>
</blockquote>
<h5 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h5><p>expire key timeout<br>为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p>delete key<br>删除key</p>
<h4 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h4><ul>
<li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，保证key一致，通过此在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，当前时间小于超时时间，则执行delete进行锁释放。</li>
</ul>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.devframe.util;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * &lt;b&gt;redis分布式锁的实现&lt;/b&gt;&lt;/br&gt;</span></div><div class="line"><span class="comment"> * 还有一些失败机制没处理，以后在使用测试阶段，完善。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/20 9:22&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisLock.class);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * redis连接</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Jedis jedis;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 锁定资源名，锁key，保证唯一。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 资源上锁的最长时间，超时自动解锁单位秒，&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 建议设置成死的，如果设置不当容易影响效率，严重造成死锁。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> expireTime = Integer.valueOf(PropertyUtil.get(<span class="string">"redisLock.expireTime"</span>));</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 线程获取不到锁，休眠的时间，单位ms</span></div><div class="line"><span class="comment">     * 避免系统资源浪费</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sleepTime = Long.valueOf(PropertyUtil.get(<span class="string">"redisLock.sleepTime"</span>));</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当前锁超时的时间戳，单位毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTimeOut = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取锁状态，锁中断状态&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 值为false的时候中断获取锁&lt;/br&gt;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> interrupted = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 构造方法</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jedis    redis连接</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 上锁key，唯一标识</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(Jedis jedis, String lockName)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lockName == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"lockName is required"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.jedis = jedis;</div><div class="line">        <span class="comment">// 重命名的前缀，可以不加，也可以自定义，保证唯一即可。</span></div><div class="line">        <span class="keyword">this</span>.lockName = <span class="string">"lock"</span> + lockName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取锁。如果锁已被其他线程获取，则进行等待，直到拿到锁为止。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.lockCheck();</div><div class="line">            <span class="keyword">long</span> id = jedis.setnx(lockName, lockName);</div><div class="line">            <span class="keyword">if</span> (id == <span class="number">0L</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">/**</span></div><div class="line"><span class="comment">                     * 没有获取到锁则进行等待睡眠时间，再去重新获取锁&lt;/br&gt;</span></div><div class="line"><span class="comment">                     * 这里使用随机时间可能会好一点,可以防止饥饿进程的出现,即,当同时到达多个进程,</span></div><div class="line"><span class="comment">                     * 只会有一个进程获得锁,其他的都用同样的频率进行尝试,后面有来了一些进行,</span></div><div class="line"><span class="comment">                     * 也以同样的频率申请锁,这将可能导致前面来的锁得不到满足.</span></div><div class="line"><span class="comment">                     * 使用随机的等待时间可以一定程度上保证公平性</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">                    Thread.sleep(<span class="keyword">this</span>.sleepTime);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    logger.error(<span class="string">"Thread is interrupted"</span>, e);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                expireTimeOut = System.currentTimeMillis() + expireTimeOut * <span class="number">1000</span> + <span class="number">1</span>;</div><div class="line">                <span class="comment">//设置redis中key的过期时间</span></div><div class="line">                jedis.expire(<span class="keyword">this</span>.lockName, expireTime);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 中断锁获取</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 中断异常</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.interrupted = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 它表示用来尝试获取锁，会立即返回，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lockCheck();</div><div class="line">        <span class="comment">//尝试获取锁</span></div><div class="line">        <span class="keyword">long</span> id = jedis.setnx(lockName, lockName);</div><div class="line">        <span class="comment">//返回结果为0 则已经存在key，已经存在锁。</span></div><div class="line">        <span class="keyword">if</span> (id == <span class="number">0L</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            expireTimeOut = System.currentTimeMillis() + expireTimeOut * <span class="number">1000</span> + <span class="number">1</span>;</div><div class="line">            <span class="comment">//设置redis中key的过期时间</span></div><div class="line">            jedis.expire(<span class="keyword">this</span>.lockName, expireTime);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。&lt;/br&gt;</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> time 等待时间</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 中断异常</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"TimeUnit is required."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> timeOutAt = now + calcSeconds(time, unit);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.lockCheck();</div><div class="line">            <span class="keyword">long</span> id = jedis.setnx(<span class="keyword">this</span>.lockName, <span class="keyword">this</span>.lockName);</div><div class="line">            <span class="comment">// id = 0 表示加锁失败</span></div><div class="line">            <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 获取锁超时</span></div><div class="line">                <span class="keyword">if</span> (System.currentTimeMillis() &gt; timeOutAt) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 休眠一段时间，线程再继续获取锁。</span></div><div class="line">                Thread.sleep(<span class="keyword">this</span>.sleepTime);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//获取锁成功，设置锁过期时间戳</span></div><div class="line">                expireTimeOut = System.currentTimeMillis() + expireTimeOut * <span class="number">1000</span> + <span class="number">1</span>;</div><div class="line">                jedis.expireAt(<span class="keyword">this</span>.lockName, expireTimeOut);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * &lt;b&gt;释放锁&lt;b/&gt;</span></div><div class="line"><span class="comment">     * 当前时间小于过期时间，则锁未超时，删除锁，&lt;/br&gt;</span></div><div class="line"><span class="comment">     * 过了超时时间，redis已经删除了该key。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &lt; expireTimeOut) &#123;</div><div class="line">            jedis.del(lockName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//TODO 涉及到 Condition 例外一个重要内容，以后再实现这个方法</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"did not supported."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 检查当前线程资源redis连接和锁的状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockCheck</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (jedis == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Jedis is required."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!interrupted) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Thread is interrupted."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * TimeUnit单位时间转换成毫秒</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> long</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">calcSeconds</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.DAYS) &#123;</div><div class="line">            <span class="keyword">return</span> time * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.HOURS) &#123;</div><div class="line">            <span class="keyword">return</span> time * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.MINUTES) &#123;</div><div class="line">            <span class="keyword">return</span> time * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.SECONDS) &#123;</div><div class="line">            <span class="keyword">return</span> time * <span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unit == TimeUnit.MILLISECONDS) &#123;</div><div class="line">            <span class="keyword">return</span> time;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//后面的不实现了，基本上用不到。</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"cannot be resolved."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># redis lock</div><div class="line"># s</div><div class="line">redisLock.expireTime=1</div><div class="line"># ms</div><div class="line">redisLock.sleepTime=100</div></pre></td></tr></table></figure></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试就选用最经典的秒杀系统吧，使用分布式锁可以控制资源。</p>
<p>下面模拟500人秒杀100件商品。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.devframe.util;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/20 14:12&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockTest</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 100件物品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> goodsNum = <span class="number">100</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 500人</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> personNum = <span class="number">500</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 不加锁的情况</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personNum; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">if</span> (goodsNum &gt; <span class="number">0</span>) &#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取了锁"</span>);</div><div class="line">                    System.out.println(<span class="string">"商品剩余："</span> + --goodsNum);</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 加上分布锁</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personNum; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                Jedis jedis = RedisUtil.getJedis();</div><div class="line">                <span class="comment">//初始化锁，key保持一致</span></div><div class="line">                Lock lock = <span class="keyword">new</span> RedisLock(jedis, <span class="string">"aa"</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock.lock();</div><div class="line">                    <span class="keyword">if</span> (goodsNum &gt; <span class="number">0</span>) &#123;</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"获取了锁"</span>);</div><div class="line">                        System.out.println(<span class="string">"商品剩余："</span> + --goodsNum);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="comment">//释放锁，并且释放redis连接</span></div><div class="line">                    lock.unlock();</div><div class="line">                    RedisUtil.returnResource(jedis);</div><div class="line">					</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不加锁的部分结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Thread-100获取了锁</div><div class="line">商品剩余：-3</div><div class="line">Thread-99获取了锁</div><div class="line">商品剩余：5</div><div class="line">商品剩余：6</div><div class="line">Thread-98获取了锁</div><div class="line">商品剩余：-5</div><div class="line">商品剩余：7</div><div class="line">商品剩余：-4</div><div class="line">商品剩余：0</div><div class="line">商品剩余：1</div><div class="line">Thread-105获取了锁</div><div class="line">商品剩余：-6</div></pre></td></tr></table></figure></p>
<p>上锁的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Thread-8获取了锁</div><div class="line">商品剩余：5</div><div class="line">Thread-238获取了锁</div><div class="line">商品剩余：4</div><div class="line">Thread-72获取了锁</div><div class="line">商品剩余：3</div><div class="line">Thread-137获取了锁</div><div class="line">商品剩余：2</div><div class="line">Thread-402获取了锁</div><div class="line">商品剩余：1</div><div class="line">Thread-337获取了锁</div><div class="line">商品剩余：0</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>并发量大的时候，需要考虑锁时间；</li>
<li>考虑失败情况，上锁了，但是设置超时时间失败（redis崩溃等各种情况），锁一致都没有释放，导致死锁的情况发生，现在需要做的是，把key的value设置成超时的时间，每次上锁失败都去检查一次，超时的就覆盖，可以避免死锁。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。&lt;/p&gt;
&lt;h4 id=&quot;使用Redis实现锁的原因&quot;&gt;&lt;a href=&quot;#使用Redis实现锁的原因&quot; class=&quot;headerlink&quot; title=&quot;使用Redis实现锁的原因&quot;&gt;&lt;/a&gt;使用Redis实现锁的原因&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Redis有很高的性能；&lt;/li&gt;
&lt;li&gt;Redis命令对此支持较好，实现起来比较方便。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
      <category term="redis" scheme="http://blog.wuwii.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字解析</title>
    <link href="http://blog.wuwii.com/java-volatile.html"/>
    <id>http://blog.wuwii.com/java-volatile.html</id>
    <published>2017-11-19T03:58:03.000Z</published>
    <updated>2017-11-30T05:54:16.248Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h3><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<a id="more"></a>
<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = i + 1;</div></pre></td></tr></table></figure></p>
<p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<ol>
<li>通过在总线加LOCK#锁的方式；</li>
<li>通过缓存一致性协议。</li>
</ol>
<p>这2种方式都是硬件层面上提供的方式。</p>
<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/212219343783699.jpg" alt="image"></p>
<h3 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h3><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>一个很经典的例子就是银行账户转账问题：</p>
<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>同样地反映到并发编程中会出现什么结果呢？<br>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = 9;</div></pre></td></tr></table></figure></p>
<p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。<br>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//线程1执行的代码</div><div class="line">int i = 0;</div><div class="line">i = 10;</div><div class="line"> </div><div class="line">//线程2执行的代码</div><div class="line">j = i;</div></pre></td></tr></table></figure></p>
<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 <code>j = i</code>，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int i = 0;              </div><div class="line">boolean flag = false;</div><div class="line">i = 1;                //语句1  </div><div class="line">flag = true;          //语句2</div></pre></td></tr></table></figure></p>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 10;    //语句1</div><div class="line">int r = 2;    //语句2</div><div class="line">a = a + 3;    //语句3</div><div class="line">r = a*a;     //语句4</div></pre></td></tr></table></figure></p>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/212305263939989.jpg" alt="image"></p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();   <span class="comment">//语句1</span></div><div class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p> 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i  = 10;</div></pre></td></tr></table></figure>
<p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h4 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h4><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = 10;         //语句1</div><div class="line">y = x;         //语句2</div><div class="line">x++;           //语句3</div><div class="line">x = x + 1;     //语句4</div></pre></td></tr></table></figure>
<p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h4 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h4><p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h4 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h4><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p><strong>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</strong></p>
<p>下面就来具体介绍下<code>happens-before</code>原则（先行发生原则）：</p>
<ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li>
</ol>
<p>这8条原则摘自《深入理解Java虚拟机》。</p>
<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>下面我们来解释一下前4条规则：<br>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h3 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h3><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<h4 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h4><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ol>
<p>先看一段代码，假如线程1先执行，线程2后执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1</span></div><div class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">while</span>(!stop)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//线程2</span></div><div class="line">stop = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是用volatile修饰之后就变得不一样了：</p>
<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程1读取到的就是最新的正确的值。</p>
<h4 id="volatile保证原子性吗？"><a href="#volatile保证原子性吗？" class="headerlink" title="volatile保证原子性吗？"></a>volatile保证原子性吗？</h4><p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，</p>
<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>把上面的代码改成以下任何一种都可以达到效果：</p>
<ol>
<li><p>采用synchronized：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>采用Lock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inc++;</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>采用AtomicInteger：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  AtomicInteger inc = <span class="keyword">new</span> AtomicInteger();</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc.getAndIncrement();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在java 1.5的<code>java.util.concurrent.atomic</code>包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<h4 id="volatile能保证有序性吗？"><a href="#volatile能保证有序性吗？" class="headerlink" title="volatile能保证有序性吗？"></a>volatile能保证有序性吗？</h4><p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<ol>
<li>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li>
</ol>
<p>可能上面说的比较绕，举个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//x、y为非volatile变量</div><div class="line">//flag为volatile变量</div><div class="line"> </div><div class="line">x = 2;        //语句1</div><div class="line">y = 0;        //语句2</div><div class="line">flag = true;  //语句3</div><div class="line">x = 4;         //语句4</div><div class="line">y = -1;       //语句5</div></pre></td></tr></table></figure></p>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面举的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//线程1:</div><div class="line">context = loadContext();   //语句1</div><div class="line">inited = true;             //语句2</div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h4 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h4><p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>下面这段话摘自《深入理解Java虚拟机》：</p>
<blockquote>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
</blockquote>
<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<ol>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>
<h3 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h3><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<ol>
<li>对变量的写操作不依赖于当前值；</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ol>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<h4 id="状态标记量"><a href="#状态标记量" class="headerlink" title="状态标记量"></a>状态标记量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"> </div><div class="line"><span class="keyword">while</span>(!flag)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</div><div class="line">    flag = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();  </div><div class="line">inited = <span class="keyword">true</span>;            </div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<h4 id="double-check"><a href="#double-check" class="headerlink" title="double check"></a>double check</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于为何需要这么写请参考：<br>《Java 中的双重检查（Double-Check）》<br><a rel="external nofollow" target="_blank" href="http://blog.csdn.net/dl88250/article/details/5439024">http://blog.csdn.net/dl88250/article/details/5439024</a><br><a rel="external nofollow" target="_blank" href="http://www.iteye.com/topic/652440">http://www.iteye.com/topic/652440</a></p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p><strong>文章转载<a rel="external nofollow" target="_blank" href="http://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a></strong></p>
<h3 id="最后附上自己的学习代码"><a href="#最后附上自己的学习代码" class="headerlink" title="最后附上自己的学习代码"></a>最后附上自己的学习代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.wuwii.test.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Kai</span></div><div class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> &lt;pre&gt;2017/11/18 9:20&lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc1;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc2;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 并发中不适用int， 使用jdk1.5的原子操作类</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> AtomicInteger inc3 = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 自增，不保证原子性</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用synchronized保证原子性</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase1</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc1++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用Lock保证原子性</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increase2</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inc2++;</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用jdk1.5的原子操作类，保证原子性</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increase3</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc3.getAndIncrement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取系统运行默认线程数，理论上只有一条主线程，需要注意的是，但是在idea上中默认多了一个monitor ctrlbreak线程。</span></div><div class="line">        <span class="comment">// 可参考 http://blog.csdn.net/xiaolinzi007/article/details/44487851</span></div><div class="line">        <span class="keyword">int</span> defaultActiveCount = Thread.activeCount();</div><div class="line">        <span class="keyword">int</span> threadCount = <span class="number">10</span>;</div><div class="line">        <span class="keyword">int</span> increaseCount = <span class="number">1000</span>;</div><div class="line">        <span class="keyword">final</span> VolatileTest test = <span class="keyword">new</span> VolatileTest();</div><div class="line">        <span class="comment">// 创建10个线程，分别自增1000次。</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; increaseCount; i1++) &#123;</div><div class="line">                    test.increase();</div><div class="line">                    test.increase1();</div><div class="line">                    test.increase2();</div><div class="line">                    test.increase3();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//保证前面的线程都执行完。</span></div><div class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; defaultActiveCount) &#123;</div><div class="line">           Thread.yield();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 打印最终结果，理论结果10 * 1000 = 10000。</span></div><div class="line">        System.out.printf(<span class="string">"自增后inc为：%d%n"</span>, test.inc);</div><div class="line">        System.out.printf(<span class="string">"自增后inc1为：%d%n"</span>, test.inc1);</div><div class="line">        System.out.printf(<span class="string">"自增后inc2为：%d%n"</span>, test.inc2);</div><div class="line">        System.out.printf(<span class="string">"自增后inc3为：%d%n"</span>, test.inc3.get());</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 状态标记，利用volatile可见性属性，保持线程有序执行</span></div><div class="line"><span class="comment">         * &lt;p&gt;写一个线程做完事情后将标记赋值true，线程二一直阻塞标记为true时执行&lt;p/&gt;</span></div><div class="line"><span class="comment">         */</span></div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">3000</span>);</div><div class="line">                FlagTest.flag = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (!FlagTest.flag) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.out.printf(<span class="string">"%s s后flag改为true%n"</span>, <span class="number">3</span> - i);</div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    i++;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.printf(<span class="string">"flag为true 了"</span>);</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 使用volatile场景&lt;/br&gt;</span></div><div class="line"><span class="comment"> * 1. 状态标记量: 并发时候保证程序按照有序运行&lt;/br&gt;</span></div><div class="line"><span class="comment"> * 2. double check：并发中为了减少同步的开销，于是有了双重检查模式。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlagTest</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * 状态标记量</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 双重检查单例模式</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> FlagTest instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FlagTest</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 双重检查double check</span></div><div class="line"><span class="comment">     * &lt;p&gt;并发情况下为了减少同步的开销，于是有了双重检查模式。&lt;/p&gt;</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> FlagTest</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FlagTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (FlagTest.class) &#123;</div><div class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</div><div class="line">                    instance = <span class="keyword">new</span> FlagTest();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">自增后inc为：9996</div><div class="line">自增后inc1为：10000</div><div class="line">自增后inc2为：10000</div><div class="line">自增后inc3为：10000</div><div class="line">3 s后flag改为true</div><div class="line">2 s后flag改为true</div><div class="line">1 s后flag改为true</div><div class="line">flag为true</div></pre></td></tr></table></figure></p>
<p>刚才的inc++操作来说，这个操作其实细分为三步，读inc的值给temp，将temp+1，赋值给inc。</p>
<ol>
<li>当线程1将inc读入内存，然后被阻塞。</li>
<li>线程2也将inc读入内存中，然后执行过第二步，temp+1，然后被阻塞。</li>
<li>线程1被唤醒，此时并没有对inc执行写操作，所以线程1不需要重新从内存读，所以执行完+1操作被赋值后重新写入主存中。</li>
<li>线程2被唤醒，由于inc执行了写操作，导致线程2中的inc缓存失效，所以从内存中重新读进来此时的inc值，由于已经执行过第二步了，此时将最新的temp赋值给inc，然后重新写入内存。就在刚才那一步发生了数据不一致性，此时的inc总共被加了一次。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Java内存模型，原子性，可见性，有序性的理解；</li>
<li>volatile修饰的变量具有什么样的特性：可见性，禁止重排序；</li>
<li>并发中的使用方法和运用场景。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内存模型的相关概念&quot;&gt;&lt;a href=&quot;#内存模型的相关概念&quot; class=&quot;headerlink&quot; title=&quot;内存模型的相关概念&quot;&gt;&lt;/a&gt;内存模型的相关概念&lt;/h3&gt;&lt;p&gt;大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
      <category term="并发编程" scheme="http://blog.wuwii.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>20171117</title>
    <link href="http://blog.wuwii.com/20171117.html"/>
    <id>http://blog.wuwii.com/20171117.html</id>
    <published>2017-11-17T14:08:03.000Z</published>
    <updated>2017-11-21T00:50:48.616Z</updated>
    
    <content type="html"><![CDATA[<p>今天天气可真是差啊，下班后出门骑了辆小黄车，没骑到一百米，雨就下起来，只好放下，毕竟大晚上撑伞骑车不太安全，只好选择去公交车站坐公交把。</p>
<p>我的天，一上公交车，还没坐一站路，堵瞎了，我这人虽然每次都是慢半拍的人，喜欢慢节奏的事情，但是了，堵车我最不喜欢的事情，关键我还坐公交车上。</p>
<p>后来接到一个消息说她被前男友骚扰了，说实话啊，我最讨厌的就是渣男了，但是还是要注意形象，去安慰下把，我也是搞不懂状况啊，多了不写了，就是堵了半个小时下车了，准备去她学校看看吧，这路人都不让走的，车一辆接一辆的。终于换车后，堵了一会儿，接到消息说她要回家了，长吁一口气了，其实我挺害怕的，但是听到消息的第一刻就是想到江歌案，所以我才想赶过去，不想写下去了，其实女孩子追到被逼回家了的，这也太可恶了吧。</p>
<p>搞到很晚才回，想到去拿快递，不错，居然没关门，拿回来一看，打开快递，没看码子，拆开试穿了一下，我的妈啊，这么大，我买的衣服全发成大码了，只能去实体店换了，（牌子就不暴露了，好坑。</p>
<p>今天下个班，搞得好累啊，好好睡个觉，明天周六上午还要去公司培训。</p>
<p>晚安/。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天天气可真是差啊，下班后出门骑了辆小黄车，没骑到一百米，雨就下起来，只好放下，毕竟大晚上撑伞骑车不太安全，只好选择去公交车站坐公交把。&lt;/p&gt;
&lt;p&gt;我的天，一上公交车，还没坐一站路，堵瞎了，我这人虽然每次都是慢半拍的人，喜欢慢节奏的事情，但是了，堵车我最不喜欢的事情，关
    
    </summary>
    
      <category term="碎碎念" scheme="http://blog.wuwii.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="心情" scheme="http://blog.wuwii.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 中HashMap源码分析</title>
    <link href="http://blog.wuwii.com/java-hashmap.html"/>
    <id>http://blog.wuwii.com/java-hashmap.html</id>
    <published>2017-11-16T03:08:03.000Z</published>
    <updated>2017-11-27T07:55:24.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap-文档"><a href="#HashMap-文档" class="headerlink" title="HashMap 文档"></a>HashMap 文档</h3><blockquote>
<p>　HashMap是基于哈希表的Map接口实现的,此实现提供所有可选的映射操作。存储的是<code>&lt;key，value&gt;</code>对的映射，允许多个null值和一个null键。但此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br> 　除了HashMap是非同步以及允许使用null外，HashMap 类与 Hashtable大致相同。<br>　 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。</p>
<p>　　HashMap 的实例有两个参数影响其性能：<code>初始容量</code> 和<code>加载因子</code>。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。<strong>加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。</strong>     </p>
<p>　　通常，默认<code>加载因子</code> (0.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。<strong>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</strong><br>　　注意，此实现<code>不是同步</code>的。 如果多个线程同时访问一个HashMap实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。这通常是通过同步那些用来封装列表的 对象来实现的。但如果没有这样的对象存在，则应该使用{@link Collections#synchronizedMap Collections.synchronizedMap}来进行“包装”，该方法最好是在创建时完成，为了避免对映射进行意外的非同步操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap(...));</div></pre></td></tr></table></figure></p>
<p>由所有此类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不会在将来不确定的时间发生任意不确定行为的风险。</p>
<p>注意，迭代器的<code>快速失败</code>行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
</blockquote>
<a id="more"></a>
<p><strong>jdk版本：jdk1.8.0_144</strong></p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组（散列桶）中的每一个元素都是链表。<img src="http://ov62kaxkk.bkt.clouddn.com/hashMap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p>
<h4 id="解决Hash冲突"><a href="#解决Hash冲突" class="headerlink" title="解决Hash冲突"></a>解决Hash冲突</h4><p> HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了<code>链地址法（拉链法）</code>。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。<br> 有时候计算Hash值的时候，会出现相同的情况，这样两个key就存储到相同的位置上了，这个时候会出现<code>Hash碰撞</code>。</p>
<h3 id="HashMap的属性"><a href="#HashMap的属性" class="headerlink" title="HashMap的属性"></a>HashMap的属性</h3><h4 id="实现的接口和继承的类"><a href="#实现的接口和继承的类" class="headerlink" title="实现的接口和继承的类"></a>实现的接口和继承的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>实际上HashMap没有从AbstractMap父亲中继承任何属性，从实现的接口上看，HashMap拥有克隆和序列化的属性。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认初始容量16，必须为2的幂</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"></div><div class="line">    <span class="comment">//最大容量</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line">    <span class="comment">//默认加载因子</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//使用红黑树而不是链表的阈值</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></div><div class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></div><div class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="comment">//table是一个Node&lt;K,V&gt;[]数组类型，而Node&lt;K,V&gt;实际上就是一个元素值为&lt;key,value&gt;对的单向链表。</span></div><div class="line">    <span class="comment">//哈希表的"key-value键值对"都是存储在Node&lt;K,V&gt;数组中的。 </span></div><div class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">    <span class="comment">//用来指向entrySet()返回的set集合</span></div><div class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//HashMap的大小,即保存的键值对的数量</span></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="comment">//用来实现fail-fast机制的，记录HashMap结构化修改的次数</span></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"></div><div class="line">    <span class="comment">//下次需扩容的临界值，size&gt;=threshold就会扩容</span></div><div class="line">    <span class="comment">//如果table数组没有被分配，则该值为初始容量值16；或若该值为0，也表明该值为初始容量值</span></div><div class="line">    <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">    <span class="comment">//加载因子</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>table是一个Node[]数组类型，而Node实际上就是一个单向链表，哈希桶数组。哈希表的”key-value键值对”都是存储在Node数组中的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现Map.Entry&lt;K,V&gt;接口</span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//hash码</span></div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next; <span class="comment">//指向链表中下一个实例</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">            <span class="keyword">this</span>.hash = hash;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</div><div class="line"></div><div class="line">        <span class="comment">//返回此映射项的哈希值:key值的哈希码与value值的哈希码按位异或的结果</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//用指定值替换对应于此项的值,并返回旧值</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">            V oldValue = value;</div><div class="line">            value = newValue;</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//比较指定对象与此项的相等性</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                    Objects.equals(value, e.getValue()))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方，而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p>
<h5 id="loadFactor加载因子"><a href="#loadFactor加载因子" class="headerlink" title="loadFactor加载因子"></a>loadFactor加载因子</h5><p>HashMap的初始化大小length为16（默认值），默认加载因子0.75，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<h5 id="size大小"><a href="#size大小" class="headerlink" title="size大小"></a>size大小</h5><p>HashMap中实际存在的键值对数量。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>HashMap提供了四种方式的构造器，可以构造一个带指定初始容量和加载因子的空HashMap，构造一个带指定初始容量和默认加载因子(0.75)的空 HashMap，构造一个默认初始容量为16和默认加载因子为0.75的空HashMap，以及构造一个包含指定Map的元素的HashMap，容量与指定Map容量相同，加载因子为默认的0.75。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//找出“大于Capacity”的最小的2的幂,使Hash表的容量保持为2的次方倍</span></div><div class="line">    <span class="comment">//算法的思想：通过使用逻辑运算来替代取余，这里有一个规律，就是当N为2的次方（Power of two），那么X％N==X&amp;(N-1)。</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//&gt;&gt;&gt; 无符号右移,高位补0</span></div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">//a|=b的意思就是把a和b按位或然后赋值给a</span></div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构造一个带指定初始容量和加载因子的空HashMap</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                               initialCapacity);</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                               loadFactor);</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构造一个带指定初始容量和默认加载因子(0.75)的空 HashMap</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构造一个具有默认初始容量 (16)和默认加载因子 (0.75)的空 HashMap</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构造一个映射关系与指定 Map相同的新 HashMap,容量与指定Map容量相同，加载因子为默认的0.75</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">        putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h4><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">方法一：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line">方法二：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。<br><img src="http://tech.meituan.com/img/java-hashmap/hashMap%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE.png" alt="image"></p>
<h4 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h4><p>HashMap提供了put(K key, V value)、putAll(Map&lt;? extends K, ? extends V&gt; m)这些添加键值对的方法。<br>HashMap的put方法执行过程可以通过下图来理解，<br><img src="http://ov62kaxkk.bkt.clouddn.com/hashMap%20put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p>
<ol>
<li><p>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
</li>
<li><p>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
</li>
<li><p>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
</li>
<li><p>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
</li>
<li><p>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
</li>
<li><p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
</li>
</ol>
<h5 id="put方法源码"><a href="#put方法源码" class="headerlink" title="put方法源码"></a>put方法源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * 在此映射中关联指定值与指定键。如果该映射以前包含了一个该键的映射关系，则旧值被替换。</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定值将要关联的键</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> value 指定键将要关联的值</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 与 key关联的旧值；如果 key没有任何映射关系，则返回 null。（返回 null 还可能表示该映射之前将null与 key关联。）</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 用于实现 Map.put()和相关的方法</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> hash 键的hash码</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> evict evict=false：表明该hash表处于初始化创建的过程中</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="comment">//步骤 1 ：tab为空则创建  </span></div><div class="line">        <span class="comment">//此处分两种情况：1.当table为null时，用默认容量16初始化table数组；2.当table非空时</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//旧hash表为null或旧hash表长度为0</span></div><div class="line">            n = (tab = resize()).length;  <span class="comment">//初始化hash表的长度（16）</span></div><div class="line">        <span class="comment">//步骤 2</span></div><div class="line">        <span class="comment">//此处又分为两种情况：1.key的hash值对应的那个节点为空；2.key的hash值对应的那个节点不为空</span></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//该key的hash值对应的那个节点为空，即表示还没有元素被散列至此</span></div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//则创建一个新的new Node&lt;&gt;(hash, key, value, next);</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">             <span class="comment">//该key的hash值对应的那个节点不为空，先与链表上的第一个节点p比较</span></div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            <span class="comment">// 步骤 3：节点key存在，直接覆盖value  </span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                e = p;</div><div class="line">                <span class="comment">// 步骤 4：判断该链为红黑树  </span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">            <span class="comment">// 步骤 5：该链为链表 的情况下进行遍历table</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;  </div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理 TREEIFY_THRESHOLD = 8  </span></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// key已经存在的话</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    p = e;  <span class="comment">//向后查找</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//若该key对应的value已经存在，则用新的value取代旧的value</span></div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">                V oldValue = e.value;</div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        <span class="comment">// 步骤 6：如果加入该键值对后超过最大阀值，则进行resize操作 ，就扩容  threshold：</span></div><div class="line">        <span class="comment">//单词解释--阈(yu)值,不念阀(fa)值！顺便学下语文咯。  </span></div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)  </div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//将指定映射的所有映射关系复制到此映射中，这些映射关系将替换此映射目前针对指定映射中所有键的所有映射关系。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        putMapEntries(m, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//用于帮助实现Map.putAll()方法 和Map构造器，当evict=false时表示构造初始HashMap。</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> s = m.size(); <span class="comment">//得到指定Map的大小</span></div><div class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></div><div class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</div><div class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</div><div class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);  <span class="comment">//得到按指定Map大小计算出的HashMap所需的容量</span></div><div class="line">                <span class="keyword">if</span> (t &gt; threshold)  <span class="comment">//如果容量大于阈值</span></div><div class="line">                    threshold = tableSizeFor(t);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)  <span class="comment">//指定Map的大小&gt;扩容临界值,扩容  </span></div><div class="line">                resize();</div><div class="line">            <span class="comment">//通过迭代器，将“m”中的元素逐个添加到HashMap中</span></div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</div><div class="line">                K key = e.getKey();</div><div class="line">                V value = e.getValue();</div><div class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="HashMap的扩容机制resize"><a href="#HashMap的扩容机制resize" class="headerlink" title="HashMap的扩容机制resize"></a>HashMap的扩容机制resize</h4><p>在HashMap的四种构造函数中并没有对其成员变量Node<k,v>[] table进行任何初始化的工作，那么HashMap是如何构造一个默认初始容量为16的空表的？该初始化的诱发条件是在向HashMap中添加第一对<key,value>时，通过<code>put(K key, V value) -&gt; putVal(hash(key), key, value, false, true) -&gt; resize()</code>方法。故HashMap中尤其重要的resize()方法主要实现了两个功能：</key,value></k,v></p>
<ol>
<li>在table数组为null时，对其进行初始化，默认容量为16；</li>
<li>当tables数组非空，但需要调整HashMap的容量时，将hash表容量翻倍。</li>
</ol>
<p>jdk1.8中的resize：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//resize()方法作用有两种：1.初始化hash表的容量，为16； 2.将hash表容量翻倍</span></div><div class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">        Node&lt;K,V&gt;[] oldTab = table;  <span class="comment">//旧hash表</span></div><div class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//旧hash表容量</span></div><div class="line">        <span class="keyword">int</span> oldThr = threshold; <span class="comment">//旧hash表阈值</span></div><div class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;  <span class="comment">//新hash表容量与扩容临界值</span></div><div class="line">        <span class="comment">//2.旧hash表非空，则表容量翻倍</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; </div><div class="line">            <span class="comment">//如果当前的hash表长度已经达到最大值，则不在进行调整</span></div><div class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">                threshold = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">return</span> oldTab;</div><div class="line">            &#125;  <span class="comment">//更新新hash表容量：翻倍</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">                <span class="comment">//更新扩容临界值</span></div><div class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">            newCap = oldThr; </div><div class="line">        <span class="comment">//1. 初始化hash表容量，设为默认值16，并且计算临界值。</span></div><div class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置下次扩容的临界值</span></div><div class="line">        threshold = newThr;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        <span class="comment">//创建一个初始容量为新hash表长度的newTab数组</span></div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">        table = newTab;</div><div class="line">        <span class="comment">//如果旧hash表非空，则按序将旧hash表中的元素重定向到新hash表</span></div><div class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">                Node&lt;K,V&gt; e;  <span class="comment">//e按序指向oldTab数组中的元素，即每个链表中的头结点</span></div><div class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                    oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">//如果链表只有一个头节点</span></div><div class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                    <span class="comment">// 如果节点是红黑树</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                    <span class="comment">//对链表进行秩序维护：因为我们使用的是两倍扩容的方法，所以每个桶里面的元素必须要么待在原来的</span></div><div class="line">                    <span class="comment">//索引所对应的位置，要么在新的桶中位置偏移两倍</span></div><div class="line">                    <span class="keyword">else</span> &#123; </div><div class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                        Node&lt;K,V&gt; next;</div><div class="line">                        <span class="keyword">do</span> &#123;</div><div class="line">                            next = e.next;</div><div class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                    loHead = e;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    loTail.next = e;</div><div class="line">                                loTail = e;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                    hiHead = e;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    hiTail.next = e;</div><div class="line">                                hiTail = e;</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                            loTail.next = <span class="keyword">null</span>;</div><div class="line">                            newTab[j] = loHead;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                            hiTail.next = <span class="keyword">null</span>;</div><div class="line">                            newTab[j + oldCap] = hiHead;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newTab;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>扩容是使用2次幂的扩展(指长度扩为原来2倍)，所以，<br><strong>经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</strong>。</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="image"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt="image"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="http://ov62kaxkk.bkt.clouddn.com/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="image"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>HashMap提供了get(Object key)、containsKey(Object key)、containsValue(Object value)这些查找键值对的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回指定key所映射的value；如果对于该键来说，此映射不包含任何映射关系，则返回 null</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">//key的哈希值为数组下标</span></div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">//检查第一个节点</span></div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> first; </div><div class="line">            <span class="comment">//如果第一个节点不对，则向后检查</span></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果此映射包含对于指定键的映射关系，则返回 true。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果此映射将一个或多个键映射到指定值，则返回 true。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; V v;</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//外层循环搜索数组</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</div><div class="line">                <span class="comment">//内层循环搜索链表</span></div><div class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</div><div class="line">                        (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="清空与删除"><a href="#清空与删除" class="headerlink" title="清空与删除"></a>清空与删除</h4><p>HashMap提供了remove(Object key)删除键值对、clear()清除所有键值对的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从此映射中移除指定键的映射关系（如果存在）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">            <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 用于实现 Map.remove()方法和其他相关的方法</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> hash 键的hash值</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</div><div class="line">        <span class="comment">//table数组非空，键的hash值所指向的数组中的元素非空</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;  <span class="comment">//node指向最终的结果结点，e为链表中的遍历指针</span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;   <span class="comment">//检查第一个节点，如果匹配成功</span></div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                node = p;</div><div class="line">            <span class="comment">//如果第一个节点匹配不成功，则向后遍历链表查找</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                            ((k = e.key) == key ||</div><div class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                            node = e;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        p = e;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)  <span class="comment">//删除node结点</span></div><div class="line">                    tab[index] = node.next;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    p.next = node.next;</div><div class="line">                ++modCount;</div><div class="line">                --size;</div><div class="line">                afterNodeRemoval(node);</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//从此映射中移除所有映射关系</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">            size = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</div><div class="line">                tab[i] = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Java 8 中HashMap是数组+链表+红黑树；</li>
<li>哈希桶数组table的长度length大小必须为2的n次方，也就是我想要创建一个长度为19的HashMap，那么它需要创建的大小为32；HashMap 的 bucket 数组大小一定是2的幂，如果 new 的时候指定了容量且不是2的幂，实际容量会是最接近(大于)指定容量的2的幂，比如 new HashMap&lt;&gt;(19)，比19大且最接近的2的幂是32，实际容量就是32。</li>
<li>没有特殊要求，负载因子使用默认值0.75，并且它可以大于1；加载因子是表示Hsah表中元素的填满的程度。若加载因子越大，填满的元素越多，好处是，空间利用率高了，但冲突的机会加大了。反之，加载因子越小，填满的元素越少，好处是，冲突的机会减小了，但空间浪费多了。冲突的机会越大，则查找的成本越高；反之,查找的成本越小，因而,查找时间就越小.</li>
<li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap，HashTable的并发性不如ConcurrentHashMap；</li>
<li>扩容特别消耗性能，初始化的时候，尽量控制好HashMap的大小，避免频繁扩容；</li>
<li>HashMap 在 new 后并不会立即分配哈希桶数组，而是第一次 put 时初始化，类似 ArrayList 在第一次 add 时分配空间。</li>
<li>HashMap 在 put 的元素数量大于 <code>Capacity * LoadFactor</code>（默认<code>16 * 0.75</code>） 之后会进行扩容。</li>
<li>Java 8在哈希碰撞的链表长度达到TREEIFY_THRESHOLD（默认8)后，会把该链表转变成树结构，提高了性能。</li>
<li>Java 8在 resize() 的时候，通过巧妙的设计，减少了 rehash 的性能消耗。</li>
</ol>
<p><strong>参考文章</strong></p>
<p><a rel="external nofollow" target="_blank" href="http://blog.csdn.net/qq_27093465/article/details/52207135">Java 8系列之重新认识HashMap</a><br><a rel="external nofollow" target="_blank" href="http://www.cnblogs.com/CherishFX/p/4739712.html">jdk1.8.0_45源码解读——HashMap的实现</a><br><a rel="external nofollow" target="_blank" href="https://www.cnblogs.com/rogerluo1986/p/5851300.html">HashMap数据结构</a><br><a rel="external nofollow" target="_blank" href="http://blog.csdn.net/u011411283/article/details/48024999">HashMap的性能提升从之链表到二叉树</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap-文档&quot;&gt;&lt;a href=&quot;#HashMap-文档&quot; class=&quot;headerlink&quot; title=&quot;HashMap 文档&quot;&gt;&lt;/a&gt;HashMap 文档&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　HashMap是基于哈希表的Map接口实现的,此实现提供所有可选的映射操作。存储的是&lt;code&gt;&amp;lt;key，value&amp;gt;&lt;/code&gt;对的映射，允许多个null值和一个null键。但此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&lt;br&gt; 　除了HashMap是非同步以及允许使用null外，HashMap 类与 Hashtable大致相同。&lt;br&gt;　 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。&lt;/p&gt;
&lt;p&gt;　　HashMap 的实例有两个参数影响其性能：&lt;code&gt;初始容量&lt;/code&gt; 和&lt;code&gt;加载因子&lt;/code&gt;。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。&lt;strong&gt;加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。&lt;/strong&gt;     &lt;/p&gt;
&lt;p&gt;　　通常，默认&lt;code&gt;加载因子&lt;/code&gt; (0.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。&lt;strong&gt;在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。&lt;/strong&gt;&lt;br&gt;　　注意，此实现&lt;code&gt;不是同步&lt;/code&gt;的。 如果多个线程同时访问一个HashMap实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。这通常是通过同步那些用来封装列表的 对象来实现的。但如果没有这样的对象存在，则应该使用{@link Collections#synchronizedMap Collections.synchronizedMap}来进行“包装”，该方法最好是在创建时完成，为了避免对映射进行意外的非同步操作。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Map m = Collections.synchronizedMap(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap(...));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由所有此类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不会在将来不确定的时间发生任意不确定行为的风险。&lt;/p&gt;
&lt;p&gt;注意，迭代器的&lt;code&gt;快速失败&lt;/code&gt;行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt;。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>解决Hash碰撞冲突方法总结</title>
    <link href="http://blog.wuwii.com/hash-crash.html"/>
    <id>http://blog.wuwii.com/hash-crash.html</id>
    <published>2017-11-15T13:08:03.000Z</published>
    <updated>2017-11-16T01:13:47.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hash碰撞冲突"><a href="#Hash碰撞冲突" class="headerlink" title="Hash碰撞冲突"></a>Hash碰撞冲突</h3><p>我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突。如下将介绍如何处理冲突，当然其前提是一致性hash。</p>
<a id="more"></a>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>开放地执法有一个公式:<code>Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)</code><br>其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。<br>如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。<br>如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
<h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h4><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。<br>比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止</p>
<h4 id="链地址法（拉链法）"><a href="#链地址法（拉链法）" class="headerlink" title="链地址法（拉链法）"></a>链地址法（拉链法）</h4><p>将所有关键字为同义词的记录存储在同一<code>线性链表</code>中。如下：</p>
<p><img src="http://img.blog.csdn.net/20160918154444663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<h4 id="建立一个公共溢出区"><a href="#建立一个公共溢出区" class="headerlink" title="建立一个公共溢出区"></a>建立一个公共溢出区</h4><p>假设哈希函数的值域为<code>[0,m-1]</code>,则设向量<code>HashTable[0..m-1]</code>为基本表，另外设立存储空间向量<code>OverTable[0..v]</code>用以存储发生冲突的记录。</p>
<h4 id="拉链法的优缺点"><a href="#拉链法的优缺点" class="headerlink" title="拉链法的优缺点"></a>拉链法的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</li>
<li>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</li>
<li>开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</li>
<li>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p>
<p><strong>文章转载 <a rel="external nofollow" target="_blank" href="http://blog.csdn.net/zeb_perfect/article/details/52574915">解决Hash碰撞冲突方法总结</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hash碰撞冲突&quot;&gt;&lt;a href=&quot;#Hash碰撞冲突&quot; class=&quot;headerlink&quot; title=&quot;Hash碰撞冲突&quot;&gt;&lt;/a&gt;Hash碰撞冲突&lt;/h3&gt;&lt;p&gt;我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突。如下将介绍如何处理冲突，当然其前提是一致性hash。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哈希算法" scheme="http://blog.wuwii.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
